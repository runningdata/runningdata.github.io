
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <script type="text/javascript">
    (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
    })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
    
    _st('install','yNiKTKaAnwd1uuxVMfiE','2.0.0');
  </script>
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5b99dfd487346155d274c0c49c3fb869";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>

  
    <title>Will&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Will Chen">
    

    
    <meta name="description" content="左右水色 右手天光">
<meta property="og:type" content="website">
<meta property="og:title" content="Will's Blog">
<meta property="og:url" content="https://runningdata.github.io/page/20/index.html">
<meta property="og:site_name" content="Will's Blog">
<meta property="og:description" content="左右水色 右手天光">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Will's Blog">
<meta name="twitter:description" content="左右水色 右手天光">

    
    <link rel="alternative" href="/atom.xml" title="Will&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Will&#39;s Blog" title="Will&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Will&#39;s Blog">Will&#39;s Blog</a></h1>
				<h2 class="blog-motto">简易 变易 不易</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
                                                <form class="search" action="/search/index.html" method="get" accept-charset="utf-8" target="_blank">
                                                        <label>搜索</label>
                                                <input name="s" type="hidden" value= null ><input type="text" class="st-default-search-input" name="q" size="30" placeholder="搜索"><br>
                                                </form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/docker-centos-6.4安装手记/" title="docker-centos-6.4安装手记" itemprop="url">docker-centos-6.4安装手记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T09:04:54.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="version-Base-not-defined-in-file-libdevmapper-so-1-02-with-link-time-reference"><a href="#version-Base-not-defined-in-file-libdevmapper-so-1-02-with-link-time-reference" class="headerlink" title="version Base not defined in file libdevmapper.so.1.02 with link time reference"></a>version Base not defined in file libdevmapper.so.1.02 with link time reference</h2><p>yum install device-mapper-event-libs -y</p>
<p>参考： <a href="http://qicheng0211.blog.51cto.com/3958621/1582909" target="_blank" rel="external">http://qicheng0211.blog.51cto.com/3958621/1582909</a></p>
<h2 id="can’t-initialize-iptables-table-nat’"><a href="#can’t-initialize-iptables-table-nat’" class="headerlink" title="can’t initialize iptables table `nat’"></a>can’t initialize iptables table `nat’</h2><p>编译内核的时候没有选中iptable_nat module相关的组件。<br>重新到内核文件夹中make </p>
<h2 id="GCC-4-8-or-higher-required"><a href="#GCC-4-8-or-higher-required" class="headerlink" title="GCC 4.8 or higher required"></a>GCC 4.8 or higher required</h2><p>参考：<a href="https://gist.github.com/stephenturner/e3bc5cfacc2dc67eca8b" target="_blank" rel="external">https://gist.github.com/stephenturner/e3bc5cfacc2dc67eca8b</a></p>
<p>参考：</p>
<ul>
<li><a href="http://blog.csdn.net/scaleqiao/article/details/46633011" target="_blank" rel="external">http://blog.csdn.net/scaleqiao/article/details/46633011</a></li>
<li></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    

    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/youdaonote/">youdaonote</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/azkaban源码追踪(2)-——-手动触发flow调度/" title="azkaban源码追踪(2)-——-手动触发flow调度" itemprop="url">azkaban源码追踪(2)-——-手动触发flow调度</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T09:04:53.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>对应的操作是进入到某个project中，然后单次执行下面的某个flow。会触发web-server这边与exec-server的远程调用去执行flow。</p>
<h4 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h4><ul>
<li>Web-server<ul>
<li>ExecutorServlet.doGet</li>
<li>ExecutorManager</li>
</ul>
</li>
<li>exec-server<ul>
<li>ExecutorServlet.doGet</li>
<li>FlowRunnerManager</li>
<li>FlowRunner</li>
<li>ExecutableFlowBase</li>
<li>ExecutableNode</li>
<li>JobRunner</li>
<li>JobTypeManager</li>
<li>Job</li>
<li>AzkabanProcessBuilder</li>
</ul>
</li>
</ul>
<p>#### </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    

    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/youdaonote/">youdaonote</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/19/akka-in-action-读书笔记（8）/" title="akka in action 读书笔记（8）" itemprop="url">akka in action 读书笔记（8）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-08-19T09:50:33.000Z" itemprop="datePublished"> 发表于 2016-08-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>系统结构。</p>
<ul>
<li>pipe和filter模型</li>
<li>scatter-gather模型</li>
<li>路由</li>
<li>Recipient list</li>
<li>Aggregator</li>
<li>Become/Unbecome</li>
</ul>
<p>如果有很多工作单元并行运行的话，那么怎样协调它们的工作？有一些可以并行执行，有的任务A需要在前置任务B完成之后才能执行。</p>
<p>通过实现几个经典的Enterprise Integration Pattern，Akka使我们能够充分利用好它的并发功能。</p>
<p>先了解以下最简单的pipe和filter模型，它是基于消息传递的系统的默认模型，经典模型是顺序执行。然后介绍 Scatter-Gather模型，这种模型提供了各种使任务并行的方式。</p>
<h2 id="8-1-pipe-和-filter"><a href="#8-1-pipe-和-filter" class="headerlink" title="8.1 pipe 和 filter"></a>8.1 pipe 和 filter</h2><p>pipe的定义就是，一个进程或者线程把它的结果交给下一个进程或线程作为输入。许多人都是从它的发源地unix了解到pipe模型的。这些pipe组件的组合，被称为pipeline。</p>
<h4 id="8-1-1-Enterprise-integration-pattern-Pipes-and-Filters"><a href="#8-1-1-Enterprise-integration-pattern-Pipes-and-Filters" class="headerlink" title="8.1.1 Enterprise integration pattern Pipes and Filters"></a>8.1.1 Enterprise integration pattern Pipes and Filters</h4>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    

    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/akka/">akka</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/17/akka-in-action-读书笔记（7）/" title="akka in action 读书笔记（7）" itemprop="url">akka in action 读书笔记（7）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-08-17T03:02:12.000Z" itemprop="datePublished"> 发表于 2016-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ul>
<li>配置</li>
<li>日志</li>
<li>单点app</li>
<li>web app</li>
<li>发布</li>
</ul>
<p>只是了解actor和ActorSysten显然是不够的，一个完成的app在发布之前应该要包含其他必备功能。</p>
<h2 id="7-1-配置"><a href="#7-1-配置" class="headerlink" title="7.1 配置"></a>7.1 配置</h2><p>akka使用了Typesafe的配置库。可以定义一些属性，然后直接在代码里引用。还有优雅的方式自动按照时间merge并override多个文件中的多个属性。对于配置还有一个比较重要的就是能够分test, dev, prod环境。</p>
<h4 id="7-1-1-牛刀小试"><a href="#7-1-1-牛刀小试" class="headerlink" title="7.1.1 牛刀小试"></a>7.1.1 牛刀小试</h4><p>首先看一下Typesafe定义配置文件的实例：<br><img src="/imgs/akka/akka_7_config_example.png" alt="配置内容示例"></p>
<p>我们使用ConfigurationFactory来加载配置文件；<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load()</div></pre></td></tr></table></figure></p>
<p>它会按照以下顺序找默认的配置文件：</p>
<ul>
<li>application.properties</li>
<li>application.json</li>
<li>application.conf. 这种说明一下是HOCON格式的，基于json，但是可读性更强</li>
</ul>
<p>也可以同时支持以上所有的文件类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">hostname=&quot;localhost&quot; </div><div class="line">MyAppl &#123;</div><div class="line">   version = 10</div><div class="line">   description = &quot;My application&quot;</div><div class="line">   database &#123;</div><div class="line">     connect=&quot;jdbc:mysql://localhost/mydata&quot;</div><div class="line">     user=&quot;me&quot;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>对于大多数app来说，这些配置就已经足够使用了。这种配置可读性强，易于分组管理属性，JDBC就是一个绝佳的例子。对于依赖注入的框架，需要把item写进控制他们的对象中去，这里有一个更简单的方法。</p>
<p>下面看一下怎样使用上面定义的属性：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> applicationVersion = config.getInt(<span class="string">"MyAppl.version"</span>)</div><div class="line"><span class="keyword">val</span> databaseConnectSting = config.getString(<span class="string">"MyAppl.database.connect"</span>)</div></pre></td></tr></table></figure></p>
<p>也可以分开获取连接串<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> databaseCfg = configuration.getConfig(<span class="string">"MyAppl.database"</span>)</div><div class="line"><span class="keyword">val</span> databaseConnectSting = databaseCfg.getString(<span class="string">"connect"</span>)</div></pre></td></tr></table></figure></p>
<p>配置文件中包含的属性一般都是app名称、版本号等，一般会在程序中多次使用它们。</p>
<p>我们还可以使用环境变量来设置变量：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hostname=$&#123;?<span class="type">HOST_NAME</span>&#125;</div></pre></td></tr></table></figure></p>
<p>？代表我们会在系统环境变量中获取该变量的值。因为我们并不能保证有这个环境变量，所以还是先定义一个默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hostname=&quot;localhost&quot;</div><div class="line">hostname=$&#123;?HOST_NAME&#125;</div></pre></td></tr></table></figure></p>
<h4 id="7-1-2-使用默认值"><a href="#7-1-2-使用默认值" class="headerlink" title="7.1.2 使用默认值"></a>7.1.2 使用默认值</h4><p>还是看JDBC配置。开发环境我们可能配置地址为localhost，但是有人要看demo的话，肯定要改成别的地址。最简单的方法就是复制配置文件，重新命名这个文件，然后让代码读取这个文件的配置内容。问题是这样我们就在两个位置分别有了两个可以相互替代的配置文件。如果还要切换新环境的话，就成了3个了。</p>
<p>配置库包含一个fall-back机制，默认配置会被放进一个对象中，然后这个对象被作为fall-back机制的配置source。见下图：<br><img src="/imgs/akka/akka_7_config_fallback.png" alt="fall-back配置"></p>
<p>注意：这个机制里使用到的属性必须在配置文件中存在默认值，如果找不到的话，就会报错了。</p>
<p>fall-back机制为我们提供默认的配置，那么我们怎样配置默认值呢？应该在jar文件的根目录下的reference.conf配置，每个库都应该包含自己的默认配置。配置库会找到所有的reference.conf文件，整个这些配置到fall-back结构中。这样，某个库所需要的所有的属性都有了默认值。</p>
<p>前面说到配置库是支持多种配置文件的，你可以在一个app中使用多个不同类型的配置文件。每个文件都可以作为下一个文件的fall-back。</p>
<p>下图展示了配置库使用多个文件构建配置tree的优先级：<br><img src="/imgs/akka/akka_7_priority_fallback.png" alt="配置fall-back结构的优先级"></p>
<p>多数app只需要一种配置文件就可以了。但是如果你定了多个，那么默认值之间的覆盖关系就是上图中，上面的覆盖下面的配置。</p>
<p>默认读取文件是 application.{conf,json,properties}。有两种方式自定义配置文件，一种是load的时候指定<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"myapp"</span>)</div></pre></td></tr></table></figure></p>
<p>这样它就会去找myapp.{conf,json,properties}。</p>
<p>另一种方式是使用系统变量。有时这种使用起来比较方便，我们可以构建bash脚本的时候给app指定(比去jar和war里面找要好一些)。</p>
<ul>
<li>config.resource 此变量指定项目resource中配置文件完整名称，例如： application.conf</li>
<li>config.file  文件系统中配置文件的全名</li>
<li>config.url   </li>
</ul>
<p>当使用load不传参的时候，就会使用系统属性了，使用系统属性指定的配置文件的时候，就不会再去搜索各种文件类型了：conf, json and properties。</p>
<h4 id="7-1-3-akka配置"><a href="#7-1-3-akka配置" class="headerlink" title="7.1.3 akka配置"></a>7.1.3 akka配置</h4><p>上面介绍了怎样配置app的属性，但是如果我们想修改akka本身的一些配置怎么办呢？akka是怎样使用配置库的呢？有可能是有多个ActorSystem，每个Actorsystem都有自己对应的配置。当创建ActorSystem的时候没有指定配置的话，ActorSystem会使用默认值自己创建。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"mySystem"</span>)</div></pre></td></tr></table></figure>
<p>这里内部调用了<code>ConfigFactory.load()</code>。</p>
<p>我们也可以指定配置文件位置：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> configuration = <span class="type">ConfigFactory</span>.load(<span class="string">"mysystem"</span>)</div><div class="line"><span class="keyword">val</span> systemA = <span class="type">ActorSystem</span>(<span class="string">"mysystem"</span>,configuration)</div></pre></td></tr></table></figure></p>
<p>这个配置就已经存在于这个app了，可以通过如下方式访问；<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> mySystem = <span class="type">ActorSystem</span>(<span class="string">"myAppl"</span>)</div><div class="line"><span class="keyword">val</span> config = mySystem.settings.config</div><div class="line"><span class="keyword">val</span> applicationDescription = config.getString(<span class="string">"myAppl.name"</span>)</div></pre></td></tr></table></figure></p>
<h4 id="7-1-4-多系统"><a href="#7-1-4-多系统" class="headerlink" title="7.1.4 多系统"></a>7.1.4 多系统</h4><p>有时候，在单个实例上我们需要启动多个子系统，每个子系统应该有自己的配置。</p>
<p>假如我们使用了多个JVM，他们基于同一个jar文件。我们就是用系统变量来解决这个问题。每启动一个新的进程，就是用一个不同的配置文件。但是配置里多数都是相同的，只有少数几个配置需要修改。我们使用include来解决这个问题</p>
<p>下面是baseConfig.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MyAppl &#123;</div><div class="line"> version = 10</div><div class="line"> description = &quot;My application&quot;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>我们使用一个共享变量version，还有不同的变量description。下面是子系统的配置文件subAppl.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">include &quot;baseConfig&quot;</div><div class="line">MyAppl &#123;</div><div class="line"> description = &quot;Sub Application&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意include的位置。</p>
<p>如果子系统运行在同一个jvm里呢？那样我们就不能使用系统变量来读取其他的配置文件了。那我们就把两个系统的配置文件合二为一，指定app名称，下面是combined.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MyAppl &#123;</div><div class="line">   version = 10</div><div class="line">   description = &quot;My application&quot;</div><div class="line">&#125;</div><div class="line">subApplA &#123;</div><div class="line">   MyAppl &#123;</div><div class="line">   description = &quot;Sub application&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们使用了subApplA的子树，然后把它放在了configuration chain的上端。This is called lifting a configuration, because the configuration path is shortened.。见下图；<br><img src="/imgs/akka/akka_7_lift_config_part.png" alt="Lifting configuration part"></p>
<p>当我们请求MyAppl.description的时候，返回”Sub application”因为它被设置在配置中的最高层级上，请求MyAppl.version获得10，因为配置的高层级上没有它的定义，所以它使用fall-back机制获取到了10.</p>
<p>下面代码展示了怎样同时使用lift和callback，注意fallback被chain了起来：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> configuration = <span class="type">ConfigFactory</span>.load(<span class="string">"combined"</span>)</div><div class="line"> <span class="keyword">val</span> subApplACfg = configuration.getConfig(<span class="string">"subApplA"</span>)</div><div class="line"> <span class="comment">// 把configuration作为fall-back</span></div><div class="line"> <span class="keyword">val</span> config = subApplACfg.withFallback(configuration)</div></pre></td></tr></table></figure></p>
<p>说的不多，但是这些配置就已经够用了。</p>
<h2 id="7-2-日志"><a href="#7-2-日志" class="headerlink" title="7.2 日志"></a>7.2 日志</h2><p>下一个app必备的功能就是写日志。日志库这个东西众口难调，akka实现了一个日志adapter支持多种日志框架。日志关心两个东西，定义log级别以及定义log内容。</p>
<h4 id="7-2-1-Akka-app中记录日志"><a href="#7-2-1-Akka-app中记录日志" class="headerlink" title="7.2.1 Akka app中记录日志"></a>7.2.1 Akka app中记录日志</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line"> <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</div><div class="line"> ...</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，创建logger的时候需要使用ActorSystem。 logging adapter使用ActorSystem的eventStream发送日志信息给eventhandler。eventStream是Akka中的订阅系统。eventhandler收到日志信息后，使用定义的日志框架记录下来。这样，每个actor都能记录日志，而只有一个eventHandler actor依赖指定的日志框架。另一个好处就是IO，IO在并发环境下会特别慢。在高性能的app里，我们不希望等待打日志的过程。使用eventHandler就不用任何等待。下面列出了默认创建event-handler需要的配置信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">akka &#123;</div><div class="line"> # Event handlers to register at boot time</div><div class="line"> # (Logging$DefaultLogger logs to STDOUT)</div><div class="line"> event-handlers = [&quot;akka.event.Logging$DefaultLogger&quot;]</div><div class="line"> # Options: ERROR, WARNING, INFO, DEBUG</div><div class="line"> loglevel = &quot;DEBUG&quot;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>eventHandler并没有使用任何log框架，而是把log到了标准输出。下面是一个自定义的eventHandler代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span>.<span class="type">InitializeLogger</span></div><div class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span>.<span class="type">LoggerInitialized</span></div><div class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span>.<span class="type">Error</span></div><div class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span>.<span class="type">Warning</span></div><div class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span>.<span class="type">Info</span></div><div class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span>.<span class="type">Debug</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEventListener</span> <span class="keyword">extends</span> <span class="title">Actor</span></span></div><div class="line">&#123;</div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">     <span class="keyword">case</span> <span class="type">InitializeLogger</span>(_) =&gt;</div><div class="line">        sender ! <span class="type">LoggerInitialized</span></div><div class="line">     <span class="keyword">case</span> <span class="type">Error</span>(cause, logSource, logClass, message) =&gt;</div><div class="line">        println( <span class="string">"ERROR "</span> + message)</div><div class="line">     <span class="keyword">case</span> <span class="type">Warning</span>(logSource, logClass, message) =&gt;</div><div class="line">        println( <span class="string">"WARN "</span> + message)</div><div class="line">     <span class="keyword">case</span> <span class="type">Info</span>(logSource, logClass, message) =&gt;</div><div class="line">        println( <span class="string">"INFO "</span> + message)</div><div class="line">     <span class="keyword">case</span> <span class="type">Debug</span>(logSource, logClass, message) =&gt;</div><div class="line">        println( <span class="string">"DEBUG "</span> + message)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这只是一个简单的示例。Akka内置了两个eventHandler的实现，一个是上面的输出到STDOUT的，还有一个就是SLF4J。需要在配置文件中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">akka &#123;</div><div class="line"> event-handlers =</div><div class="line"> [&quot;akka.event.slf4j.Slf4jEventHandler&quot;]</div><div class="line"> # Options: ERROR,</div><div class="line"> WARNING,</div><div class="line"> INFO, DEBUG</div><div class="line"> loglevel = &quot;DEBUG&quot;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h4 id="7-2-2-使用日志功能"><a href="#7-2-2-使用日志功能" class="headerlink" title="7.2.2 使用日志功能"></a>7.2.2 使用日志功能</h4><p>重新定义logger：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line"> <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</div><div class="line"> ...</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>第二个参数就是日志的source。这里就是这个类的实例。可以mixin ActorLogging trait来简化代码。</p>
<p>打日志过程中还可以使用placeholder<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log.debug(<span class="string">"two parameters: &#123;&#125;, &#123;&#125;"</span>, <span class="string">"one"</span>,<span class="string">"two"</span>)</div></pre></td></tr></table></figure></p>
<h4 id="7-2-3-控制日志功能"><a href="#7-2-3-控制日志功能" class="headerlink" title="7.2.3 控制日志功能"></a>7.2.3 控制日志功能</h4><p>有时我们想自由控制日志的输出内容，比如查看生产环境的某些信息。看一下这个配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">akka &#123;</div><div class="line">   # logging must be set to DEBUG to use any of the options below</div><div class="line">   loglevel = DEBUG</div><div class="line">   # Log the complete configuration at INFO level when the actor</div><div class="line">   # system is started. This is useful when you are uncertain of</div><div class="line">   # what configuration is used.</div><div class="line">   log-config-on-start = on</div><div class="line">   debug &#123;</div><div class="line">   # logging of all user-level messages that are processed by</div><div class="line">   # Actors that use akka.event.LoggingReceive enable function of</div><div class="line">   # LoggingReceive, which is to log any received message at</div><div class="line">   # DEBUG level</div><div class="line">   # 把所有启用了akka.event.LoggingReceive的收到的user-leve的debug level的日志信息都打印出来</div><div class="line">   receive = on</div><div class="line"></div><div class="line">   # enable DEBUG logging of all AutoReceiveMessages</div><div class="line">   # (Kill, PoisonPill and the like)</div><div class="line">   autoreceive = on</div><div class="line">   # enable DEBUG logging of actor lifecycle changes</div><div class="line">   # (restarts, deaths etc)</div><div class="line">   lifecycle = on</div><div class="line">   # enable DEBUG logging of all LoggingFSMs for events,</div><div class="line">   # transitions and timers</div><div class="line">   fsm = on</div><div class="line">   # enable DEBUG logging of subscription (subscribe/unsubscribe)</div><div class="line">   # changes on the eventStream</div><div class="line">   event-stream = on</div><div class="line">   &#125;</div><div class="line">   remote &#123;</div><div class="line">   # If this is &quot;on&quot;, Akka will log all outbound messages at</div><div class="line">   # DEBUG level, if off then they are not logged</div><div class="line">   log-sent-messages = on</div><div class="line">   # If this is &quot;on,&quot; Akka will log all inbound messages at</div><div class="line">   # DEBUG level, if off then they are not logged</div><div class="line">   log-received-messages = on</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应使用logger的代码是：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= <span class="type">LoggingReceive</span> &#123;</div><div class="line"> <span class="keyword">case</span> ... =&gt; ...</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，只要我们设置属性akka.debug.receive 为on，我们actor收到的所有message就都可以被log出来了。</p>
<p>好了。日志就介绍到这里。</p>
<h2 id="7-3-发布基于Akka的app"><a href="#7-3-发布基于Akka的app" class="headerlink" title="7.3 发布基于Akka的app"></a>7.3 发布基于Akka的app</h2><p>这一节介绍发布应用的两种方式，一种是独立app，另一种是基于play-min的web app。</p>
<h4 id="7-3-1-独立app"><a href="#7-3-1-独立app" class="headerlink" title="7.3.1 独立app"></a>7.3.1 独立app</h4><p>我们使用akka的插件MicroKernel创建独立app。先弄一个HelloWorld Actor，只接收message，恢复hello。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Actor</span></span></div><div class="line">   <span class="keyword">with</span> <span class="type">ActorLogging</span> &#123;</div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">         <span class="keyword">case</span> msg:<span class="type">String</span> =&gt;</div><div class="line">         <span class="keyword">val</span> hello = <span class="string">"Hello %s"</span>.format(msg)</div><div class="line">         sender ! hello</div><div class="line">         log.info(<span class="string">"Sent response &#123;&#125;"</span>,hello)</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面我们创建HelloWorldCaller，它负责调用上面的 HelloWorld actor。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldCaller</span>(<span class="params">timer:<span class="type">Duration</span>, actor:<span class="type">ActorRef</span></span>)</span></div><div class="line"> <span class="keyword">extends</span> <span class="type">Actor</span> <span class="keyword">with</span> <span class="type">ActorLogging</span> &#123;</div><div class="line"> </div><div class="line">   <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTick</span>(<span class="params">msg:<span class="type">String</span></span>)</span></div><div class="line"></div><div class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>() &#123;</div><div class="line">       <span class="keyword">super</span>.preStart()</div><div class="line">       <span class="comment">// 使用akka scheduler给自己发送message</span></div><div class="line">       context.system.scheduler.schedule(</div><div class="line">         timer, 	<span class="comment">// 首次触发之前的时长</span></div><div class="line">         timer,		<span class="comment">// 周期 </span></div><div class="line">         self,		<span class="comment">// 发往的actor，这里是自己</span></div><div class="line">         <span class="keyword">new</span> <span class="type">TimerTick</span>(<span class="string">"everybody"</span>))	<span class="comment">// 发出的message</span></div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">       <span class="keyword">case</span> msg: <span class="type">String</span> =&gt; log.info(<span class="string">"received &#123;&#125;"</span>,msg)</div><div class="line">       <span class="keyword">case</span> tick: <span class="type">TimerTick</span> =&gt; actor ! tick.msg</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个actor使用内置的schuduler周期性的生成message。每次收到TimerTick，我们都给构造方法中传进来的actor发送一个这个tick的message。当接收到一个String的message的时候，就用日志记录下来。</p>
<p>下面使用akka内核来差un构建系统，这个内核包含了一个启动接口，我们就是要实现这个接口。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> akka.actor.&#123; <span class="type">Props</span>, <span class="type">ActorSystem</span> &#125;</div><div class="line"><span class="keyword">import</span> akka.kernel.<span class="type">Bootable</span></div><div class="line"><span class="keyword">import</span> scala.concurrent.duration._</div><div class="line"><span class="comment">// 继承Bootable trait，启动app的时候就会被调用</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BootHello</span> <span class="keyword">extends</span> <span class="title">Bootable</span> </span>&#123;</div><div class="line">     </div><div class="line">     <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"hellokernel"</span>)</div><div class="line"></div><div class="line">     <span class="comment">// 当app启动的时候，会调用这个接口方法</span></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">startup</span> </span>= &#123;</div><div class="line">         <span class="keyword">val</span> actor = system.actorOf(<span class="type">Props</span>[<span class="type">HelloWorld</span>])</div><div class="line">         <span class="keyword">val</span> config = system.settings.config</div><div class="line">         <span class="keyword">val</span> timer = config.getInt(<span class="string">"helloWorld.timer"</span>)</div><div class="line">         system.actorOf(<span class="type">Props</span>(<span class="keyword">new</span> <span class="type">HelloWorldCaller</span>(timer millis, actor)))</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">shutdown</span> </span>= &#123;</div><div class="line">         system.shutdown()</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们已构建好了系统，还需要一些资源让我们的app运行起来。我们先写一下配置文件reference.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">helloWorld &#123;</div><div class="line"> timer=5000</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>我们的默认timer值是5000毫秒。注意reference.conf文件需要放在jar文件的根目录下。下面我们在application.conf里配置logger相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">akka &#123;</div><div class="line"> event-handlers =</div><div class="line"> [&quot;akka.event.slf4j.Slf4jEventHandler&quot;]</div><div class="line"> # Options: ERROR,</div><div class="line"> WARNING,</div><div class="line"> INFO, DEBUG</div><div class="line"> loglevel = &quot;DEBUG&quot;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>万事俱备。下面使用 akka-sbt-plugin 来创建依赖配置文件, 编辑plugins.sbt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">resolvers += &quot;Typesafe Repository&quot;</div><div class="line">  at &quot;http://repo.akka.io/releases/&quot; </div><div class="line"></div><div class="line">  addSbtPlugin(&quot;com.typesafe.akka&quot; % &quot;akka-sbt-plugin&quot; % &quot;2.0.1&quot;)</div></pre></td></tr></table></figure></p>
<p>为不熟悉sbt的同学解释一下。第一行添加了repository的地址。然后是一个空行，这个注意一下，它代表前一行完事儿了。下一行定义了我们需要的插件。</p>
<p>然后创建build文件， HelloKernelBuild.scala<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sbt._</div><div class="line"> <span class="keyword">import</span> <span class="type">Keys</span>._</div><div class="line"> <span class="keyword">import</span> akka.sbt.<span class="type">AkkaKernelPlugin</span></div><div class="line"> <span class="keyword">import</span> akka.sbt.<span class="type">AkkaKernelPlugin</span>.&#123; <span class="type">Dist</span>,</div><div class="line">     outputDirectory,</div><div class="line">     distJvmOptions</div><div class="line"> &#125;</div><div class="line"> <span class="class"><span class="keyword">object</span> <span class="title">HelloKernelBuild</span> <span class="keyword">extends</span> <span class="title">Build</span> </span>&#123;</div><div class="line">     <span class="keyword">lazy</span> <span class="keyword">val</span> <span class="type">HelloKernel</span> = <span class="type">Project</span>(</div><div class="line">         id = <span class="string">"hello-kernel-book"</span>,</div><div class="line">         base = file(<span class="string">"."</span>),</div><div class="line">         settings = defaultSettings</div><div class="line">         	++ <span class="type">AkkaKernelPlugin</span>.distSettings <span class="comment">// 添加akka插件的功能</span></div><div class="line">         	++ <span class="type">Seq</span>(</div><div class="line">			<span class="comment">// 构建需要的依赖</span></div><div class="line">             		libraryDependencies ++= <span class="type">Dependencies</span>.helloKernel,</div><div class="line">             		distJvmOptions in <span class="type">Dist</span> := <span class="string">"-Xms256M -Xmx1024M"</span>,</div><div class="line">			<span class="comment">// dist输出目录</span></div><div class="line">             		outputDirectory in <span class="type">Dist</span> := file(<span class="string">"target/helloDist"</span>)</div><div class="line">         	)</div><div class="line">     )</div><div class="line">     <span class="keyword">lazy</span> <span class="keyword">val</span> buildSettings = <span class="type">Defaults</span>.defaultSettings</div><div class="line">     ++ <span class="type">Seq</span>(</div><div class="line">         organization := <span class="string">"com.manning"</span>,</div><div class="line">         version := <span class="string">"0.1-SNAPSHOT"</span>,</div><div class="line">         scalaVersion := <span class="string">"2.9.1"</span>,</div><div class="line">         crossPaths := <span class="literal">false</span>,</div><div class="line">         organizationName := <span class="string">"Mannings"</span>,</div><div class="line">         organizationHomepage := <span class="type">Some</span>(url(<span class="string">"http://www.mannings.com"</span>))</div><div class="line">     )</div><div class="line">     <span class="keyword">lazy</span> <span class="keyword">val</span> defaultSettings = buildSettings ++ <span class="type">Seq</span>(</div><div class="line">         resolvers += <span class="string">"Typesafe Repo"</span> at  <span class="string">"http://repo.typesafe.com/typesafe/releases/"</span>,</div><div class="line">         <span class="comment">// compile options</span></div><div class="line">         scalacOptions ++= <span class="type">Seq</span>(<span class="string">"-encoding"</span>, <span class="string">"UTF-8"</span>, <span class="string">"-deprecation"</span>,  <span class="string">"-unchecked"</span>),</div><div class="line">         javacOptions ++= <span class="type">Seq</span>(<span class="string">"-Xlint:unchecked"</span>, <span class="string">"-Xlint:deprecation"</span>)</div><div class="line">     )</div><div class="line">&#125;  </div><div class="line"></div><div class="line"> <span class="comment">// Dependencies</span></div><div class="line"> <span class="class"><span class="keyword">object</span> <span class="title">Dependencies</span> </span>&#123;</div><div class="line">   <span class="keyword">import</span> <span class="type">Dependency</span>._</div><div class="line">   <span class="keyword">val</span> helloKernel = <span class="type">Seq</span>(akkaActor, akkaKernel, akkaSlf4j, lf4jApi, slf4jLog4j, <span class="type">Test</span>.junit, <span class="type">Test</span>.scalatest, <span class="type">Test</span>.akkaTestKit)</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Dependency</span> </span>&#123;</div><div class="line">     <span class="comment">// Versions</span></div><div class="line">     <span class="class"><span class="keyword">object</span> <span class="title">V</span> </span>&#123;</div><div class="line">       <span class="keyword">val</span> <span class="type">Scalatest</span> = <span class="string">"1.6.1"</span></div><div class="line">       <span class="keyword">val</span> <span class="type">Slf4j</span> = <span class="string">"1.6.4"</span></div><div class="line">       <span class="keyword">val</span> <span class="type">Akka</span> = <span class="string">"2.0"</span></div><div class="line">     &#125;</div><div class="line">     <span class="comment">// Compile</span></div><div class="line">     <span class="keyword">val</span> commonsCodec = <span class="string">"commons-codec"</span> % <span class="string">"commons-codec"</span>% <span class="string">"1.4"</span></div><div class="line">     <span class="keyword">val</span> commonsIo = <span class="string">"commons-io"</span>  % <span class="string">"commons-io"</span> % <span class="string">"2.0.1"</span></div><div class="line">     <span class="keyword">val</span> commonsNet = <span class="string">"commons-net"</span>  % <span class="string">"commons-net"</span> % <span class="string">"3.1"</span></div><div class="line">     <span class="keyword">val</span> slf4jApi = <span class="string">"org.slf4j"</span> % <span class="string">"slf4j-api"</span> % <span class="type">V</span>.<span class="type">Slf4j</span></div><div class="line">     <span class="keyword">val</span> slf4jLog4j = <span class="string">"org.slf4j"</span>  % <span class="string">"slf4j-log4j12"</span>% <span class="type">V</span>.<span class="type">Slf4j</span></div><div class="line">     <span class="keyword">val</span> akkaActor = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-actor"</span> % <span class="type">V</span>.<span class="type">Akka</span></div><div class="line">     <span class="keyword">val</span> akkaKernel = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-kernel"</span> % <span class="type">V</span>.<span class="type">Akka</span></div><div class="line">     <span class="keyword">val</span> akkaSlf4j = <span class="string">"com.typesafe.akka"</span>  % <span class="string">"akka-slf4j"</span> % <span class="type">V</span>.<span class="type">Akka</span></div><div class="line">     <span class="keyword">val</span> scalatest = <span class="string">"org.scalatest"</span> %% <span class="string">"scalatest"</span> % <span class="type">V</span>.<span class="type">Scalatest</span></div><div class="line">     <span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</div><div class="line">         <span class="keyword">val</span> junit = <span class="string">"junit"</span> % <span class="string">"junit"</span> %  <span class="string">"4.5"</span> % <span class="string">"test"</span></div><div class="line">         <span class="keyword">val</span> scalatest = <span class="string">"org.scalatest"</span> %% <span class="string">"scalatest"</span> % <span class="type">V</span>.<span class="type">Scalatest</span> % <span class="string">"test"</span></div><div class="line">         <span class="keyword">val</span> akkaTestKit =<span class="string">"com.typesafe.akka"</span>  % <span class="string">"akka-testkit"</span> % <span class="type">V</span>.<span class="type">Akka</span> % <span class="string">"test"</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>万事俱备了。进入项目根目录，启动sbt，执行dist命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sbt</div><div class="line">[info] Loading project</div><div class="line">definition from J:\boek\manningAkka\</div><div class="line">listings\kernel\project</div><div class="line">[info]</div><div class="line">Set current project to hello-kernel-book (in build</div><div class="line"> file:/J:/boek/manningAkka/listings/kernel/)</div><div class="line">&gt; dist</div></pre></td></tr></table></figure></p>
<p>完事儿后，查看 /target/helloDist目录，可看到4个子目录：</p>
<ul>
<li>bin 启动脚本所在的地方，包含linux和window的</li>
<li>config 运行app所需的配置文件</li>
<li>deploy jar文件所在的地方</li>
<li>lib 依赖的jar文件所在的地方</li>
</ul>
<p>使用启动脚本，启动我们的app：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./start BootHello</div></pre></td></tr></table></figure></p>
<p>观察log文件。</p>
<h4 id="7-3-2-创建web-app"><a href="#7-3-2-创建web-app" class="headerlink" title="7.3.2 创建web app"></a>7.3.2 创建web app</h4><p>相比上面独立app，这里并不多做什么。 Play-mini是基于Play的扩展。我们要做的app只是提供接口，并不提供界面。有其他的工具可以，我们只是觉得 Play-mini来做例子<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">PlayMiniHello</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"> <span class="keyword">lazy</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"webhello"</span>)</div><div class="line"> <span class="keyword">lazy</span> <span class="keyword">val</span> actor = system.actorOf(<span class="type">Props</span>[<span class="type">HelloWorld</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只要继承Application, 就集成了好多的功能，就像前面的kernel一样。web app中需要创建路由。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">PlayMiniHello</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">route</span> </span>= &#123;</div><div class="line"> 	<span class="keyword">case</span> <span class="type">GET</span>(<span class="type">Path</span>(<span class="string">"/test"</span>)) =&gt; <span class="type">Action</span> &#123;</div><div class="line"> 		<span class="type">Ok</span>(<span class="string">"TEST @ %s\n"</span>.format(<span class="type">System</span>.currentTimeMillis))</div><div class="line">	 &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在面向服务的架构里，整个app甚至就可以仅仅基于几个这样的服务映射。相比上面的kernel方式，这是唯一的区别。下面我们创建hello请求的路由，它接收一个name参数，当没有这个参数的时候就使用我们配置里的默认值。下面是从REST路径里获取参数的方式<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> writeForm = <span class="type">Form</span>(<span class="string">"name"</span> -&gt; text(<span class="number">1</span>,<span class="number">10</span>))</div></pre></td></tr></table></figure></p>
<p>这里使用了Play的From，约束长度只能在1到10之间。如果获取失败的话，就获取配置参数helloWorld.name。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">GET</span>(<span class="type">Path</span>(<span class="string">"/hello"</span>)) =&gt; <span class="type">Action</span> &#123;</div><div class="line">  <span class="comment">// 把request定已成implicit类型，方便下面进行变量绑定 </span></div><div class="line">  <span class="keyword">implicit</span> request =&gt;</div><div class="line">       <span class="keyword">val</span> name = <span class="keyword">try</span> &#123;</div><div class="line">	  <span class="comment">// 将request和我们的form进行绑定匹配</span></div><div class="line">          writeForm.bindFromRequest.get</div><div class="line">       &#125; <span class="keyword">catch</span> &#123;</div><div class="line">           <span class="keyword">case</span> ex:<span class="type">Exception</span> =&gt; &#123;</div><div class="line">             log.warning(<span class="string">"no name specified"</span>)</div><div class="line">	     <span class="comment">// 获取默认的配置参数</span></div><div class="line">             system.settings.config.getString(<span class="string">"helloWorld.name"</span>)</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在有了name，我们可以发送信息给指定的actor。但是在创建response之前我们必须等着结果，可我们不希望阻塞。所以我们返回AsyncResult，它需要一个promise。promise很像Futrue，只是Futrue是在client端使用的。有了promise，结果就一直等在producer那儿，完成处理后producer会提供这个结果。关于Futrue和Promise的更多细节会在下一章涉及。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="type">AsyncResult</span> &#123;</div><div class="line">   <span class="comment">// 使用ask方法发送request</span></div><div class="line">   <span class="keyword">val</span> resultFuture = actor ? name </div><div class="line">   <span class="comment">// 使用futrue创建一个promise</span></div><div class="line">   <span class="keyword">val</span> promise = resultFuture.asPromise</div><div class="line">   <span class="comment">// 返回结果后，就创建response</span></div><div class="line">   promise.map &#123;</div><div class="line">       <span class="keyword">case</span> res:<span class="type">String</span> =&gt; &#123;</div><div class="line">          <span class="type">Ok</span>(res)</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要使用 HelloWorld actor的response创建一个response，我们必须使用ask方法。ask方法返回一个Futrue，使用Future创建一个Promise。最后一步就是使用返回的结果填充进Promise。</p>
<p>如果超时没有收到response呢，这样map方法就不会被调用，promise里也不会被填充结果。要解决这个问题，我们继承Future，当失败的时候返回一个字符串。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> resultFuture = actor ? name recover &#123;</div><div class="line">     <span class="keyword">case</span> ex:<span class="type">AskTimeoutException</span></div><div class="line">          =&gt; <span class="string">"Timeout"</span></div><div class="line"></div><div class="line">     <span class="keyword">case</span> ex:<span class="type">Exception</span> =&gt; &#123;</div><div class="line">         log.error(<span class="string">"recover from "</span>+ex.getMessage)</div><div class="line">         <span class="string">"Exception:"</span> + ex.getMessage</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>总结一下变化：</p>
<ul>
<li>从resource文件中加载默认属性</li>
<li>抽取path中的参数</li>
<li>处理请求超时</li>
<li>并发地处理所有问题</li>
</ul>
<p>用下面这个例子来总结一下这一章的所学：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现 Application trait</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">PlayMiniHello</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">lazy</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"webhello"</span>)</div><div class="line"></div><div class="line">     <span class="keyword">lazy</span> <span class="keyword">val</span> actor = system.actorOf(<span class="type">Props</span>[<span class="type">HelloWorld</span>])</div><div class="line"></div><div class="line">     <span class="keyword">implicit</span> <span class="keyword">val</span> timeout = <span class="type">Timeout</span>(<span class="number">1000</span> milliseconds)</div><div class="line"></div><div class="line">     <span class="keyword">val</span> log = <span class="type">Logging</span>(system,<span class="type">PlayMiniHello</span>.getClass)</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">route</span> </span>= &#123;</div><div class="line">         <span class="keyword">case</span> <span class="type">GET</span>(<span class="type">Path</span>(<span class="string">"/test"</span>)) =&gt; <span class="type">Action</span> &#123;</div><div class="line">             <span class="type">Ok</span>(<span class="string">"TEST @ %sn"</span>.format(<span class="type">System</span>.currentTimeMillis))</div><div class="line">         &#125;</div><div class="line"></div><div class="line">	 <span class="comment">// 使用 helloworld actor 创建一个request</span></div><div class="line">         <span class="keyword">case</span> <span class="type">GET</span>(<span class="type">Path</span>(<span class="string">"/hello"</span>)) =&gt; <span class="type">Action</span> &#123;</div><div class="line">	     <span class="comment">// 设置request为implicit</span></div><div class="line">             <span class="keyword">implicit</span> request =&gt;</div><div class="line">             <span class="keyword">val</span> name = <span class="keyword">try</span> &#123;</div><div class="line">		    <span class="comment">// 获取name参数，具体参考Play文档</span></div><div class="line">                    writeForm.bindFromRequest.get</div><div class="line">               &#125; <span class="keyword">catch</span> &#123;</div><div class="line">                     <span class="keyword">case</span> ex:<span class="type">Exception</span> =&gt; &#123;</div><div class="line">                         log.warning(<span class="string">"no name specified"</span>)</div><div class="line">                         system.settings.config.getString(<span class="string">"helloWorld.name"</span>)</div><div class="line">                     &#125;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">	       <span class="comment">// 由于不想阻塞，我们返回AsyncResult</span></div><div class="line">               <span class="type">AsyncResult</span> &#123;</div><div class="line">		 <span class="comment">// 担心超时，创建一个recover回调函数</span></div><div class="line">                 <span class="keyword">val</span> resultFuture = actor ? name recover &#123;</div><div class="line">                     <span class="keyword">case</span> ex:<span class="type">AskTimeoutException</span> =&gt; <span class="string">"Timeout"</span></div><div class="line">                     <span class="keyword">case</span> ex:<span class="type">Exception</span> =&gt; &#123;</div><div class="line">                         log.error(<span class="string">"recover from "</span>+ex.getMessage)</div><div class="line">                         <span class="string">"Exception:"</span> + ex.getMessage</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="keyword">val</span> promise = resultFuture.asPromise</div><div class="line"></div><div class="line">                 promise.map &#123;</div><div class="line">                     <span class="keyword">case</span> res:<span class="type">String</span> =&gt; &#123;</div><div class="line">                         log.info(<span class="string">"result "</span>+res)</div><div class="line">                         <span class="type">Ok</span>(res)</div><div class="line">                     &#125;</div><div class="line">                     <span class="keyword">case</span> ex:<span class="type">Exception</span> =&gt; &#123;</div><div class="line">                         log.error(<span class="string">"Exception "</span>+ex.getMessage)</div><div class="line">                         <span class="type">Ok</span>(ex.getMessage)</div><div class="line">                     &#125;</div><div class="line">                     <span class="keyword">case</span> _ =&gt; &#123;</div><div class="line">                     <span class="type">Ok</span>(<span class="string">"Unexpected message"</span>)</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> writeForm = <span class="type">Form</span>(<span class="string">"name"</span> -&gt; text(<span class="number">1</span>,<span class="number">10</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此外我们还要处理一些小事情，指定启动app的类，这里是”PlayMiniHello.”。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Global</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">typesafe</span>.<span class="title">play</span>.<span class="title">mini</span>.<span class="title">Setup</span>(<span class="params">ch04.<span class="type">PlayMiniHello</span></span>)</span></div></pre></td></tr></table></figure></p>
<p>继承了 play.api.GlobalSettings trait，这样我们就可以使用ActorSystem的onStart和onStop方法了。</p>
<p>编辑配置文件reference.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">helloWorld &#123;</div><div class="line"> name=world</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编辑application.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">helloWorld &#123;</div><div class="line">    name=&quot;world!!!&quot;</div><div class="line">&#125;</div><div class="line">akka &#123;</div><div class="line">   event-handlers = [&quot;akka.event.slf4j.Slf4jEventHandler&quot;]</div><div class="line">   # Options: ERROR, WARNING, INFO, DEBUG</div><div class="line">   loglevel = &quot;DEBUG&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编辑项目构建文件Build.scala<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sbt._</div><div class="line"><span class="keyword">import</span> <span class="type">Keys</span>._</div><div class="line"><span class="keyword">import</span> <span class="type">PlayProject</span>._</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Build</span> <span class="keyword">extends</span> <span class="title">Build</span> </span>&#123;</div><div class="line">     <span class="keyword">lazy</span> <span class="keyword">val</span> root = <span class="type">Project</span>(id = <span class="string">"playminiHello"</span>,</div><div class="line">     base = file(<span class="string">"."</span>), settings = <span class="type">Project</span>.defaultSettings).settings(</div><div class="line">     resolvers += <span class="string">"Typesafe Repo"</span> at</div><div class="line">     <span class="string">"http://repo.typesafe.com/typesafe/releases/"</span>,</div><div class="line">     resolvers += <span class="string">"Typesafe Snapshot Repo"</span> at</div><div class="line">     <span class="string">"http://repo.typesafe.com/typesafe/snapshots/"</span>,</div><div class="line">     libraryDependencies ++= <span class="type">Dependencies</span>.hello,</div><div class="line">     <span class="comment">// 加上这一行，就可以支持sbt测试webapp了</span></div><div class="line">     mainClass in (<span class="type">Compile</span>, run) := <span class="type">Some</span>(<span class="string">"play.core.server.NettyServer"</span>))</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Dependencies</span> </span>&#123;</div><div class="line">     <span class="keyword">import</span> <span class="type">Dependency</span>._</div><div class="line">     <span class="keyword">val</span> hello = <span class="type">Seq</span>(akkaActor,</div><div class="line">         akkaSlf4j,</div><div class="line">         <span class="comment">// slf4jLog4j,</span></div><div class="line">         playmini</div><div class="line">     )</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Dependency</span> </span>&#123;</div><div class="line">     <span class="comment">// Versions</span></div><div class="line">     <span class="class"><span class="keyword">object</span> <span class="title">V</span> </span>&#123;</div><div class="line">         <span class="keyword">val</span> <span class="type">Slf4j</span> = <span class="string">"1.6.4"</span></div><div class="line">         <span class="keyword">val</span> <span class="type">Akka</span> = <span class="string">"2.0"</span></div><div class="line">     &#125;</div><div class="line">     <span class="comment">// Compile</span></div><div class="line">     <span class="keyword">val</span> slf4jLog4j = <span class="string">"org.slf4j"</span> % <span class="string">"slf4j-log4j12"</span>% <span class="type">V</span>.<span class="type">Slf4j</span></div><div class="line">     <span class="keyword">val</span> akkaActor = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-actor"</span> % <span class="type">V</span>.<span class="type">Akka</span></div><div class="line">     <span class="keyword">val</span> playmini = <span class="string">"com.typesafe"</span> %% <span class="string">"play-mini"</span> % <span class="string">"2.0-RC3"</span></div><div class="line">     <span class="keyword">val</span> akkaSlf4j = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-slf4j"</span> % <span class="type">V</span>.<span class="type">Akka</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进入sbt，运行run。app会运行在9000端口上，可以使用curl进行测试了。</p>
<h2 id="7-4-总结"><a href="#7-4-总结" class="headerlink" title="7.4 总结"></a>7.4 总结</h2><p>写的太绕口了。。不翻译了。。。。。akka各种牛逼。。。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    

    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/akka/">akka</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/15/akka-in-action-读书笔记（6）/" title="akka in action 读书笔记（6）" itemprop="url">akka in action 读书笔记（6）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-08-15T10:51:25.000Z" itemprop="datePublished"> 发表于 2016-08-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这一章我们介绍：</p>
<ul>
<li>scale out</li>
<li>分布式的卖票app</li>
<li>远程使用</li>
<li>测试分布式的actor系统</li>
</ul>
<p>这一章中，我们会拿出第二章的例子来进行scale out，也就是在更多的机器上部署同一个app。【回忆一下scale up，在更多的jvm上部署同一个app】</p>
<p>这一章只介绍scale out，下一章介绍集群使用。13章会深入scale out的一些细节。</p>
<h2 id="6-1-scale-out"><a href="#6-1-scale-out" class="headerlink" title="6.1 scale out"></a>6.1 scale out</h2><p>不要指望一下子就能够把任何app扩展到几千台机器，分布式计算是众所周知的难点。akka只是让分布式计算简单一些，让并发编程简单一些，我们这里还是使用 GoTicks.com 项目，把它弄成分布式的。</p>
<p>许多网络技术都使用RPC，这种方式尽量掩饰本地调用与远程调用的不同，主要思想是既然本地调用很简单，那么就让编程人员像调用本地方法一样调用远程方法。这种通信方式对于点对点的server连接是有效的，但是对于大型网络并不是一个好的方案。面向message的中间件可以解决这个问题，但使app理解吸收message系统到app层的代价有些大。akka另辟蹊径，远程协作者相对透明，不用修改akka代码。</p>
<p>进入探讨之前，先看一下网络拓扑的例子和一些通用术语。要是你对这些已经很了解了就直接跳到6.2.</p>
<h4 id="6-1-1-通用网络拓扑"><a href="#6-1-1-通用网络拓扑" class="headerlink" title="6.1.1 通用网络拓扑"></a>6.1.1 通用网络拓扑</h4><p><img src="/imgs/akka/akka_6_common_network_topo.png" alt="通用网络拓扑"></p>
<ul>
<li>Node: 在网络中运行着的一个app，是网络拓扑的一个连接点。一个server上可以有多个node。</li>
<li>Role： 每个node在分布式系统中都有自己指定的Role。它代表着这个node可以执行一些列的特定任务。</li>
<li>transport protocol ： node使用指定的传输协议来互相沟通，比如TCP/IP</li>
<li>membership：当许多node在同一个分布式系统中的时候，他们公用一个group membership。这个membership可以是静态或动态的。静态是指node的数量和角色都是固定不变的。动态的是允许node自由加入或离开网络，也可能在不同时刻担任不同的角色。静态的最简单，也最脆弱。动态的则可以随着node的增多动态调整node之间的关系，可以应对一些错误问题。当有node加入或者离开网络的时候，需要有一种discovery机制。</li>
</ul>
<h4 id="6-1-2-为何要分布式编程模型"><a href="#6-1-2-为何要分布式编程模型" class="headerlink" title="6.1.2 为何要分布式编程模型"></a>6.1.2 为何要分布式编程模型</h4><p>扩展多n多node的第一步是县弄出一个本地的app支持分布逻辑？我们可以只定义抽象的处理逻辑，然某个牛叉的工具去处理这些转化细节么？答案是no。只指出分布式和本地环境的区别是不够的。根据论文 A Note on Distributed Computing所说，在本地编程和分布式编程，有4个重要的区别：延迟、内存访问、部分失败、并发。下面是一个简单的总结：</p>
<ul>
<li>延迟：在协作者之间出现网络意味着每个message都需要更长的时间，可能由于各种网络原因造成延迟</li>
<li>部分失败：当系统的部分功能并不总是可见、有时消失有时又出现，我们很难确定整个系统都能正常工作。</li>
<li>内存访问： 在本地系统中获取一个内存对象的引用基本不会失败，但是对于分布式系统就失败概率就变大了。</li>
<li>并发： no one ‘owner’ of everything</li>
</ul>
<p>由于以上因素，我们不能在分布式环境中使用本地编程模型。akka的切入点恰恰相反，只需要一个分布式编程模型，同时适用于本地系统和分布式系统。前面提到的论文也提到这个观点，但是有些关心会不会把编程难度提高到分布式编程的水平。</p>
<p>时代变了。前面章节我们介绍到了并发编程的易用性。我们已经熟用了异步迭代，部分失败处理，并发之间不共享任何状态，简化了多核编程，我们已经准备好弄一个分布式环境了。</p>
<h2 id="6-2-scale-out-with-remoting"><a href="#6-2-scale-out-with-remoting" class="headerlink" title="6.2 scale out with remoting"></a>6.2 scale out with remoting</h2><p>我们先选区一个最简单的网络拓扑模型：使用两个node组成client-server 静态网络拓扑。两个node一个是前端，一个是后端。REST接口运行在前端node上，BoxOffice和所有的TicketSeller运行在后端node上。node之间互相有一个静态的网络地址引用。如下图：<br><img src="/imgs/akka/akka_6_sigle_to_cli_serv.png" alt="从单个节点到client-&gt;server的变化"></p>
<p>我们需要使用到akka-remote module。</p>
<p>在本地模式中，当有新的Event的时候，BoxOffice Actor就创建TicketSeller actor。在client-server拓扑中也是这样。只是我们可以看到使用akka-remote之后就可以远程创建与发布actor了。前端使用它知道的地址在后端找负责创建TicketSeller的BoxOffice actor。注意还有一个变化就是前端在后端远程部署了一个BoxOffice actor。</p>
<h4 id="6-2-1-动手写程序"><a href="#6-2-1-动手写程序" class="headerlink" title="6.2.1 动手写程序"></a>6.2.1 动手写程序</h4><p>在源码的chapter6文件夹里有一个对chapter2的升级版。</p>
<p>首先我们修改以下sbt文件，添加akka-remote和akka-mutlnode-testkit依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;com.typesafe.akka&quot;       %%  &quot;akka-remote&quot;                    % akkaVersion,</div><div class="line">&quot;com.typesafe.akka&quot;       %%  &quot;akka-multi-node-testkit&quot;        % akkaVersion   % &quot;test&quot;,</div></pre></td></tr></table></figure></p>
<p>调用sbt update来pull这些依赖。</p>
<h4 id="6-2-2-远程REPL"><a href="#6-2-2-远程REPL" class="headerlink" title="6.2.2 远程REPL"></a>6.2.2 远程REPL</h4><p>akka提供两种方式来获取远程node上的actor引用。一种是通过path，另一种是创建actor，获取它的引用，然后远程发布。先介绍第一种。</p>
<p>REPL控制台是一个很好的交互工具。进入到chapter6目录下，执行sbt console进入REPL，我们需要开启两个session，也就是两个REPL。为了使远程生效，我们需要在src/main/resources下提供一个配置文件application.conf，REPL启动的时候会自动加载它。</p>
<p>在REPL中执行:paste后，贴入以下代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">val conf="""</div><div class="line">akka &#123;</div><div class="line">  actor &#123;</div><div class="line">    provider = "akka.remote.RemoteActorRefProvider" // 选择 Remote ActorRef Provider来启动远程</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  // 远程配置</div><div class="line">  remote &#123; </div><div class="line">    enabled-transports = ["akka.remote.netty.tcp"] // 启用TCP</div><div class="line">    netty.tcp &#123;</div><div class="line">      hostname = "0.0.0.0"</div><div class="line">      port = 2552</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">"""</div></pre></td></tr></table></figure></p>
<p>我们会将这段配置信息加载进ActorSystem。需要注意的是它定义了一个ActorRefProvider来启动akka-remote module。顾名思义，他就是负责远程Actor的ActorRef。</p>
<p>下面代码首先引入必须的配置和actor包，然后把配置加载进了ActorSystem：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">import</span> com.typesafe.config._</div><div class="line"> <span class="keyword">import</span> com.typesafe.config._</div><div class="line"></div><div class="line"> scala&gt; <span class="keyword">import</span> akka.actor._</div><div class="line"> <span class="keyword">import</span> akka.actor._</div><div class="line"></div><div class="line"><span class="comment">// 解析字符串配置为对象config</span></div><div class="line"> scala&gt; <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.parseString(conf)</div><div class="line"> config: com.typesafe.config.<span class="type">Config</span> = ....</div><div class="line"></div><div class="line"><span class="comment">// 使用config对象创建ActorSystem</span></div><div class="line"> scala&gt; <span class="keyword">val</span> backend = <span class="type">ActorSystem</span>(<span class="string">"backend"</span>, config)</div><div class="line"> [<span class="type">Remoting</span>] <span class="type">Starting</span> remoting</div><div class="line"> .....</div><div class="line"> [<span class="type">Remoting</span>] <span class="type">Remoting</span> now listens on addresses:</div><div class="line"> [akka.tcp:<span class="comment">//backend@0.0.0.0:2551]</span></div><div class="line"> backend: akka.actor.<span class="type">ActorSystem</span> = akka:<span class="comment">//backend</span></div></pre></td></tr></table></figure></p>
<p>随着敲完最后一行，我们启动了一个启动了远程的ActorSystem。通过启动远程的config对象，我们启动了后端ActorSystem。如果忘了没有使用这个config，默认akka的application.conf里是不启用远程功能的。下面我们弄一个直接输出输入数据的小的actor：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">scala&gt; :paste</div><div class="line"><span class="comment">// Entering paste mode (ctrl-D to finish)</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line"><span class="keyword">case</span> m =&gt; println(<span class="string">s"received <span class="subst">$m</span>!"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Exiting paste mode, now interpreting.</span></div><div class="line"><span class="comment">// 使用后端ActorSystem创建这个简单的Actor并命名为simple</span></div><div class="line">scala&gt; backend.actorOf(<span class="type">Props</span>[<span class="type">Simple</span>], <span class="string">"simple"</span>)</div></pre></td></tr></table></figure></p>
<p>这个简单的actor已经运行在后端ActorSystem上了，并且有了名字simple，这样其他的node就可以找到它了。下面我们另起一个终端，开始编写前端：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">val conf = """</div><div class="line">akka &#123;</div><div class="line"></div><div class="line">  actor &#123;</div><div class="line">    provider = "akka.remote.RemoteActorRefProvider"</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  remote &#123;</div><div class="line">    enabled-transports = ["akka.remote.netty.tcp"]</div><div class="line">    netty.tcp &#123;</div><div class="line">      hostname = "0.0.0.0"</div><div class="line">      port = 2551 // 注意端口不同</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">"""</div><div class="line"></div><div class="line"> import com.typesafe.config._</div><div class="line"></div><div class="line"> import akka.actor._</div><div class="line"></div><div class="line"> val config = ConfigFactory.parseString(conf)</div><div class="line"> val frontend= ActorSystem("frontend", config)</div><div class="line"> [Remoting] Starting remoting</div><div class="line"> .....</div><div class="line"> [Remoting] Remoting now listens on addresses:</div><div class="line"> [akka.tcp://backend@0.0.0.0:2552]</div><div class="line"> frontend: akka.actor.ActorSystem = akka://frontend</div></pre></td></tr></table></figure></p>
<p>config同样被加载进了前端的actorSystem。前端actorSystem已经启用了远程，而且启动起来了。下面我们想办法在前端获取Simple Actor的引用。我们首先构建一个actor path。下图是path的组成：<br><img src="/imgs/akka/akka_6_remote_actor_path.png" alt="actor path的组成"></p>
<p>我们可以使用前端actorSystem的actorSelection方法通过path获取到后端ActorSystem的simple ActorRef：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; :paste</div><div class="line"><span class="comment">// Entering paste mode (ctrl-D to finish)</span></div><div class="line"><span class="keyword">val</span> path = <span class="string">"akka.tcp://backend@0.0.0.0:2551/user/simple"</span></div><div class="line"><span class="keyword">val</span> simple = frontend.actorSelection(path)</div><div class="line"><span class="comment">// Exiting paste mode, now interpreting.</span></div><div class="line">path: <span class="type">String</span> = akka.tcp:<span class="comment">//backend@0.0.0.0:2551/user/simple</span></div><div class="line">simple: akka.actor.<span class="type">ActorSelection</span> =</div><div class="line"><span class="type">ActorSelection</span>[<span class="type">Actor</span>[akka.tcp:<span class="comment">//backend@0.0.0.0:2551/]/user/simple]</span></div></pre></td></tr></table></figure></p>
<p>ctorSelection可以用来发送一些message给所有符合条件的actor。下面我们就在前端发送一个信息给后端：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scala&gt; simple ! <span class="string">"Hello Remote World!"</span></div></pre></td></tr></table></figure></p>
<p>切换到后端的终端上，可以看到，我们收到并打印出了这条message：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scala&gt; received <span class="type">Hello</span> <span class="type">Remote</span> <span class="type">World</span>!!</div></pre></td></tr></table></figure></p>
<p>过程是message被序列化，发送给一个TCP socket，通过远程module收到，然后反序列化，再交给后端的Simple Actor处理。</p>
<h4 id="6-2-3-远程查找"><a href="#6-2-3-远程查找" class="headerlink" title="6.2.3 远程查找"></a>6.2.3 远程查找</h4><p>我们并不会直接在RestInterface actor中直接创建BoxOffice actor，而是在后端node上找BoxOffice。如下图：<br><img src="/imgs/akka/akka_6_remotelooup_boxoffice_actor.png" alt="远程查找BoxOffice actor"><br>前面版本的RestInterface是直接创建的BoxOffice actor：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> boxOffice = context.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>], <span class="string">"boxOffice"</span>)</div></pre></td></tr></table></figure></p>
<p>这样调用的话二者就是直接的父子关系。为了让app更灵活一些，使之也能适应分布式系统，我们把这段代码放进一个trait，然后后面再mixin。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个trait必须被mixin进一个actor才能使用context</span></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BoxOfficeCreator</span> </span>&#123; <span class="keyword">this</span>: <span class="type">Actor</span> =&gt;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createBoxOffice</span></span>:<span class="type">ActorRef</span> = context.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>],<span class="string">"boxOffice"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RestApi trait包含了RestInterface actor的所有逻辑</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestInterface</span> <span class="keyword">extends</span> <span class="title">HttpServiceActor</span></span></div><div class="line">                    <span class="keyword">with</span> <span class="type">RestApi</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= runRoute(routes)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RestApi</span> <span class="keyword">extends</span> <span class="title">HttpService</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> <span class="keyword">with</span> <span class="title">BoxOfficeCreator</span> </span>&#123; actor: <span class="type">Actor</span> =&gt;</div><div class="line">  <span class="keyword">val</span> boxOffice = createBoxOffice <span class="comment">//使用BoxOfficeCreator trait中定义的方法创建BoxOffice</span></div><div class="line">	......</div><div class="line">	.....</div></pre></td></tr></table></figure></p>
<p>这样我们把创建BoxOffice的代码抽取到了一个trait中，然后在RestInterface把它设置为创建本地boxOffice的默认方法。</p>
<p>下面就定义三个入口方法：SingleNodeMain、FrontendMain、BackendMain。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单点</span></div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"singlenode"</span>, config)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> restInterface = system.actorOf(<span class="type">Props</span>[<span class="type">RestInterface</span>],</div><div class="line">                                     <span class="string">"restInterface"</span>)</div><div class="line"></div><div class="line"><span class="comment">// FrontendMain</span></div><div class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"frontend"</span>)</div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"frontend"</span>, config)</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// mixin RemoteBoxOfficeCreator trait </span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FrontendRestInterface</span> <span class="keyword">extends</span> <span class="title">RestInterface</span></span></div><div class="line">                              <span class="keyword">with</span> <span class="type">RemoteBoxOfficeCreator</span></div><div class="line"></div><div class="line">  <span class="comment">// 使用mixin的RemoteBoxOfficeCreator trait的FrontendRestInterface创建rest接口</span></div><div class="line">  <span class="keyword">val</span> restInterface = system.actorOf(<span class="type">Props</span>[<span class="type">FrontendRestInterface</span>],</div><div class="line">                                     <span class="string">"restInterface"</span>)</div><div class="line"></div><div class="line"><span class="comment">// BackendMain</span></div><div class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"backend"</span>)</div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"backend"</span>, config)</div><div class="line"></div><div class="line">  system.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>], <span class="string">"boxOffice"</span>)</div></pre></td></tr></table></figure>
<p>以上三个入口分别加载的是singlenode.conf, frontend.conf ， backend.conf配置文件里的配置。frontend.conf相对多出一个部分来指定怎样找boxoffice actor。RemoteBoxOfficeCreator负责加载这部分配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">backend &#123;</div><div class="line">  host = &quot;0.0.0.0&quot;</div><div class="line">  port = 2552</div><div class="line">  protocol = &quot;akka.tcp&quot;</div><div class="line">  system = &quot;backend&quot;</div><div class="line">  actor = &quot;user/boxOffice&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>boxoffice actor的路径是从这个配置部分获取并构建的。下面就是像前面REPL一样使用Actor Selection获取远程Actor，一旦确认后端正常，我们就可以尝试发送message了。这次我们希望使用ActorRef而不是单节点那样使用，下面是RemoteBoxOfficeCreator的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RemoteBoxOfficeCreator</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"frontend"</span>).getConfig(<span class="string">"backend"</span>)</div><div class="line">  <span class="keyword">val</span> host = config.getString(<span class="string">"host"</span>)</div><div class="line">  <span class="keyword">val</span> port = config.getInt(<span class="string">"port"</span>)</div><div class="line">  <span class="keyword">val</span> protocol = config.getString(<span class="string">"protocol"</span>)</div><div class="line">  <span class="keyword">val</span> systemName = config.getString(<span class="string">"system"</span>)</div><div class="line">  <span class="keyword">val</span> actorName = config.getString(<span class="string">"actor"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RemoteBoxOfficeCreator</span> <span class="keyword">extends</span> <span class="title">BoxOfficeCreator</span> </span>&#123; <span class="keyword">this</span>:<span class="type">Actor</span> =&gt;</div><div class="line">  <span class="keyword">import</span> <span class="type">RemoteBoxOfficeCreator</span>._</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createPath</span></span>:<span class="type">String</span> = &#123;</div><div class="line">    <span class="string">s"<span class="subst">$protocol</span>://<span class="subst">$systemName</span>@<span class="subst">$host</span>:<span class="subst">$port</span>/<span class="subst">$actorName</span>"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createBoxOffice</span></span>:<span class="type">ActorRef</span> = &#123;</div><div class="line">    <span class="keyword">val</span> path = createPath</div><div class="line">    context.actorOf(<span class="type">Props</span>(classOf[<span class="type">RemoteLookup</span>],path), <span class="string">"lookupBoxOffice"</span>) <span class="comment">// 创建一个负责寻找boxoffice actor的actor，这个actor的参数是远程boxoffice的path</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RemoteBoxOfficeCreator创建了一个额外的actor RemoteLookup来寻找boxOffice。在前面版本的akka里你可能会使用actorFor方法来直接获取一个远程actor的ActorRef。但是这个方法目前已经过期了，因为如果actor本身挂掉的话，他返回的ActorRef的表现并不完全像本地actor一样。还有就是通过actorFor返回的ActorRef可以指向一个新建的远程actor实例，这对本地context来说绝无可能。再一个原因就是不能像本地actor那样监控它的终结message。所以把这个方法废除了。取而代之的是RemoteLookup actor：</p>
<ul>
<li>后端ActorSystem可能还没有启动，或者暂时挂掉了，正在重启</li>
<li>boxOffice actor本身也可能挂掉重启中</li>
<li>理想状态下我们能先于前端启动后端</li>
</ul>
<p>RemoteLookup负责处理以上这些场景。下路是RemoteLookup在RestInterface和BoxOffice的作用，它主要负责传递message给RestInterface：<br><img src="/imgs/akka/akka_6_remotelooup_actor.png" alt="RestInterface actor"></p>
<p>RemoteLookup actor是一个只包含两种状态的状态机：identify或者active。它使用become方法在这两种状态之间进行切换。当RemoteLookup想要获取一个BoxOffice的ActorRef的时候，如果它暂时还没有，就是在identify状态。不然它就是在active状态，传递所有的message到一个有效的BoxOffice ActorRef。</p>
<p>如果RemoteLookup发现BoxOffice已经被终结了，他会在接收不到message的一段时间后，重新获取一个有效的ActorRef。我们使用RemoteDeath监控这种情况。这东西我们并不陌生，跟普通的actor监控是一样的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteLookup</span>(<span class="params">path:<span class="type">String</span></span>)</span></div><div class="line">  <span class="keyword">extends</span> <span class="type">Actor</span> <span class="keyword">with</span> <span class="type">ActorLogging</span> &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 若3秒内没有收到任何message，就发送一个ReceiveTimeout消息 </span></div><div class="line">  context.setReceiveTimeout(<span class="number">3</span> seconds)</div><div class="line">  <span class="comment">// 马上请求actor的identify</span></div><div class="line">  sendIdentifyRequest()</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sendIdentifyRequest</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="comment">// 使用path获取actor</span></div><div class="line">    <span class="keyword">val</span> selection = context.actorSelection(path)</div><div class="line">    <span class="comment">// 向actorSelection发送一个Identify message</span></div><div class="line">    selection ! <span class="type">Identify</span>(path)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= identify</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">identify</span></span>:<span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">ActorIdentity</span>(`path`, <span class="type">Some</span>(actor)) =&gt; <span class="comment">// 某个actor已经被确认(identified)了，返回它的ActorRef</span></div><div class="line">      context.setReceiveTimeout(<span class="type">Duration</span>.<span class="type">Undefined</span>) <span class="comment">// 既然当前actor已经是active了，就不用发送ReceiveTimeout了</span></div><div class="line">      log.info(<span class="string">"switching to active state"</span>)</div><div class="line">      context.become(active(actor))	<span class="comment">// 修改状态</span></div><div class="line">      context.watch(actor)		<span class="comment">// 监视</span></div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="type">ActorIdentity</span>(`path`, <span class="type">None</span>) =&gt;   <span class="comment">// actor还不可用，后端连不上，或者还没有启动</span></div><div class="line">      log.error(<span class="string">s"Remote actor with path <span class="subst">$path</span> is not available."</span>)</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="type">ReceiveTimeout</span> =&gt; <span class="comment">// 如果还没有收到message，就继续identify远程actor</span></div><div class="line">      sendIdentifyRequest()</div><div class="line"></div><div class="line">    <span class="keyword">case</span> msg:<span class="type">Any</span> =&gt;   	<span class="comment">// 在identify接收状态下，不发送任何message</span></div><div class="line">      log.error(<span class="string">s"Ignoring message <span class="subst">$msg</span>, remote actor is not ready yet."</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">active</span></span>(actor: <span class="type">ActorRef</span>): <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(actorRef) =&gt;  	<span class="comment">// 如果远程的actor被终结，RemoteLookup应修改它的状态到identify接收状态</span></div><div class="line">      log.info(<span class="string">"Actor $actorRef terminated."</span>)</div><div class="line">      log.info(<span class="string">"switching to identify state"</span>)</div><div class="line">      context.become(identify)</div><div class="line">      context.setReceiveTimeout(<span class="number">3</span> seconds)</div><div class="line">      sendIdentifyRequest()</div><div class="line"></div><div class="line">    <span class="keyword">case</span> msg:<span class="type">Any</span> =&gt; actor forward msg		<span class="comment">// 当远程actor是active的时候，向下传递所有其他message</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发送Identify message到ActorSelection来获取boxOffice的ActorRef。后端ActorSystem的远程module对应返回一个包含远程actor的ActorRef的 ActorIdentity message。</p>
<p>这样就完成了从一个单节点应用改到前后端node。除了能够远程通信，前端和后端还可以分开启动，前端会去找boxoffice，当boxoffice可用的时候就与之通信，不可用就采取其他措施。</p>
<p>最后就是运行FrontendMain和BackendMain。启动两个终端，分别使用sbt run指定入口类运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[info] ...</div><div class="line">[info] ... (sbt messages)</div><div class="line">[info] ...</div><div class="line">Multiple main classes detected, select one to run:</div><div class="line">[1] com.goticks.SingleNodeMain</div><div class="line">[2] com.goticks.FrontendMain</div><div class="line">[3] com.goticks.BackendMain</div><div class="line">Enter number:</div></pre></td></tr></table></figure></p>
<p>测试一下如果kill掉后端，再重启。</p>
<p>远程event的生命周期默认是打在日志里的，可以帮主我们更快定位问题。我们还可以使用actorSystem的eventStream方法定于远程生命周期event，后面第十章会提到。考虑到连接管理，再考虑到我们可以像本地actor一样监视远程actor，我们就没必要再针对event做什么额外操作了。</p>
<p>重新看一下修改的地方：</p>
<ul>
<li>抽出 BoxOfficeCreator trait。远程版本中向后端请求查找Boxoffice。</li>
<li>RemoteBoxOfficeCreator在RestInterface和BoxOffice之间添加了一个RemoteLookup actor。它负责传递他收到的所有的消息给boxoffice。它还identifyboxoffice的actorRef，并且远程监视boxoffice的actor。</li>
</ul>
<h4 id="6-2-4-远程发布"><a href="#6-2-4-远程发布" class="headerlink" title="6.2.4 远程发布"></a>6.2.4 远程发布</h4><p>前面说到akka提供了两种方式获取远程actor的ActorRef。下面我们介绍第二种，远程发布。</p>
<p>远程发布可以通过编程或配置实现。我们先弄一下配置方式的远程发布。它的好处就是不需要重新构建app就可以修改集群。标准的 BoxOfficeCreator trait 创建boxOffice，并把后者当做自己的一个子actor：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> boxOffice = context.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>], <span class="string">"boxOffice"</span>)</div></pre></td></tr></table></figure></p>
<p>local path是/restInterface/boxOffice，注意这里没有/user。当我们使用基于配置的远程发布的时候，我们只需要告诉前端actorSystem，创建/restInterface/boxOffice的actor的时候，应该是远程创建。通过如下配置实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actor &#123;</div><div class="line">  provider = &quot;akka.remote.RemoteActorRefProvider&quot;</div><div class="line"></div><div class="line">  deployment &#123;</div><div class="line">    /restInterface/boxOffice &#123;  // 使用这个path的actor都应该被远程发布</div><div class="line">      remote = &quot;akka.tcp://backend@0.0.0.0:2552&quot;   // 远程发布的目标地址，应该就是后端监听的端口</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基于编程的远程发布相比起来简直就没有存在的必要。大多数情况下我们都使用基于配置的远程发布。但是有时，假如你要通过CNAMES引用不同的node，写代码就方便些。当时用akka-cluster的时候，完全动态远程发布就很有意义了，因为它可以支持动态membership。下面是一个基于编程的远程发布实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> uri = <span class="string">"akka.tcp://backend@0.0.0.0:2552"</span></div><div class="line"> <span class="keyword">val</span> backendAddress = <span class="type">AddressFromURIString</span>(uri) <span class="comment">// 从uri创建一个后端地址</span></div><div class="line"> <span class="comment">// 使用远程发布范围创建一个Props</span></div><div class="line"> <span class="keyword">val</span> props = <span class="type">Props</span>[<span class="type">BoxOffice</span>].withDeploy(</div><div class="line">   <span class="type">Deploy</span>(scope = <span class="type">RemoteScope</span>(backendAddress))</div><div class="line"> )</div><div class="line"> context.actorOf(props, <span class="string">"boxOffice"</span>)</div></pre></td></tr></table></figure></p>
<p>上面代码也是在后端远程创建与发布了一个boxOffice。</p>
<p>注意，远程发布并不是akka把实际的BoxOffice的class文件传送给远程server实现，而是远程server本身就有这个actor。如果后端远程ActorSystem挂掉并重启，这个ActorRef并不会自动关联到新的远程actor实例。这个实例是通过远程发布的，所以后端ActorSystem中不能是已经启动了的。基于这两点改变，下面是新的Main方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前端不再创建boxOffice</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">BackendRemoteDeployMain</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"backend"</span>)</div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"backend"</span>, config)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 后端不再mixin一些trait，使用默认的BoxOfficeCreator</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">FrontendRemoteDeployWatchMain</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"frontend-remote-deploy"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> host = config.getString(<span class="string">"http.host"</span>)</div><div class="line">  <span class="keyword">val</span> port = config.getInt(<span class="string">"http.port"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"frontend"</span>, config)</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">RestInterfaceWatch</span> <span class="keyword">extends</span> <span class="title">RestInterface</span></span></div><div class="line">                           <span class="keyword">with</span> <span class="type">ConfiguredRemoteBoxOfficeDeployment</span></div><div class="line"></div><div class="line">  <span class="keyword">val</span> restInterface = system.actorOf(<span class="type">Props</span>[<span class="type">RestInterfaceWatch</span>],</div><div class="line">  <span class="string">"restInterface"</span>)</div><div class="line"></div><div class="line">  <span class="type">Http</span>(system).manager ! <span class="type">Bind</span>(listener = restInterface,</div><div class="line">  interface = host,</div><div class="line">  port =port)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分别在两个终端下运行这两个main方法，尝试使用httpie创建event，会看到下面的message在前端ActorSystem打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// very long message, formatted in a couple of lines to fit.</div><div class="line">INFO [RestInterface]: Received new event Event(RHCP,10), sending to</div><div class="line">Actor[akka.tcp://backend@0.0.0.0:2552/remote/akka.tcp/</div><div class="line"> frontend@0.0.0.0:2551/user/restInterface/boxOffice#-1230704641]</div></pre></td></tr></table></figure></p>
<p>这是说前端向后端发送了一个message来远程发布了boxOffice。</p>
<p>目前来说一切都顺利。可是有个问题：如果前端尝试远程发布的时候后端没有启动会咋样，因为还是会获得一个ActorRef。即便后端ActorSystem一会儿启动了，这个ActorRef还是不可用。要解决这个问题，我们还是要对这个ActorRef添加监视。我们需要像前面RemoteLookup actor那样放一个actor在RestInterface和boxOffice之间，这次是RemoteBoxOfficeForwarder。</p>
<p>我们需要稍微修改以下配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actor &#123;</div><div class="line">  provider = &quot;akka.remote.RemoteActorRefProvider&quot;</div><div class="line"></div><div class="line">  deployment &#123;</div><div class="line">    /restInterface/forwarder/boxOffice &#123;</div><div class="line">      remote = &quot;akka.tcp://backend@0.0.0.0:2552&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是ConfiguredRemoteBoxOfficeDeployment和RemoteBoxOfficeForwarder的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConfiguredRemoteBoxOfficeDeployment</span> <span class="keyword">extends</span> <span class="title">BoxOfficeCreator</span> </span>&#123; <span class="keyword">this</span>:<span class="type">Actor</span> =&gt;</div><div class="line"></div><div class="line">  <span class="comment">// 创建一个forwarder来负责监视和发布远程的BoxOffice</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createBoxOffice</span> </span>= &#123;</div><div class="line">    context.actorOf(<span class="type">Props</span>[<span class="type">RemoteBoxOfficeForwarder</span>],</div><div class="line">                           <span class="string">"forwarder"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteBoxOfficeForwarder</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> </span>&#123;</div><div class="line">  context.setReceiveTimeout(<span class="number">3</span> seconds)</div><div class="line"></div><div class="line">  <span class="comment">// 远程发布并监视BoxOffice</span></div><div class="line">  deployAndWatch()</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deployAndWatch</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> actor = context.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>], <span class="string">"boxOffice"</span>)</div><div class="line">    context.watch(actor)</div><div class="line">    log.info(<span class="string">"switching to maybe active state"</span>)</div><div class="line">    context.become(maybeActive(actor))</div><div class="line">    context.setReceiveTimeout(<span class="type">Duration</span>.<span class="type">Undefined</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= deploying</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deploying</span></span>:<span class="type">Receive</span> = &#123;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="type">ReceiveTimeout</span> =&gt;</div><div class="line">      deployAndWatch()</div><div class="line"></div><div class="line">    <span class="keyword">case</span> msg:<span class="type">Any</span> =&gt;</div><div class="line">      log.error(<span class="string">s"Ignoring message <span class="subst">$msg</span>, remote actor is not ready yet."</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">maybeActive</span></span>(actor:<span class="type">ActorRef</span>): <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(actorRef) =&gt; 	<span class="comment">// 远程发布的actor被终结，那就重新远程发布一个</span></div><div class="line">      log.info(<span class="string">"Actor $actorRef terminated."</span>)</div><div class="line">      log.info(<span class="string">"switching to deploying state"</span>)</div><div class="line">      context.become(deploying)</div><div class="line">      context.setReceiveTimeout(<span class="number">3</span> seconds)</div><div class="line">      deployAndWatch()</div><div class="line"></div><div class="line">    <span class="keyword">case</span> msg:<span class="type">Any</span> =&gt; actor forward msg</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RemoteBoxOfficeForwarder和上文的RemoteLookup特别像，都有一个状态机，不过它是 ‘deploying’ 或  ‘maybe active’。没有actor selection，我们不能确认远程actor是否已经真的被发布了。 为RemoteBoxOfficeForwarder添加远程actorSelection的任务就交给读者你了，就是当前’maybe’的状态机。</p>
<p>前端的main类mixin了ConfiguredRemoteBoxOfficeDeployment。看一下FrontendRemoteDeployWatchMain：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestInterfaceWatch</span> <span class="keyword">extends</span> <span class="title">RestInterface</span></span></div><div class="line">                         <span class="keyword">with</span> <span class="type">ConfiguredRemoteBoxOfficeDeployment</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> restInterface = system.actorOf(<span class="type">Props</span>[<span class="type">RestInterfaceWatch</span>],</div><div class="line"><span class="string">"restInterface"</span>)</div></pre></td></tr></table></figure></p>
<p>重新启动前后端的程序，测试一把。</p>
<p>我们把lookup和远程发布两种方式都可以使程序特别有韧性。即便在只有两个node的时候，我们最好也能在最开始就弄的特别有韧性。</p>
<h4 id="6-2-5-Multi-JVM-testing"><a href="#6-2-5-Multi-JVM-testing" class="headerlink" title="6.2.5 Multi-JVM testing"></a>6.2.5 Multi-JVM testing</h4><p>sbt multi-jvm插件可以用来进行跨JVM的测试，这对于分布式系统是很重要的。需要在sbt配置文件中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addSbtPlugin(&quot;com.typesafe.sbt&quot; % &quot;sbt-multi-jvm&quot; % &quot;0.3.5&quot;)</div></pre></td></tr></table></figure></p>
<p>我们需要额外添加另一个sbt构件文件来使用它。 Multi-JVM插件只支持scala DSL版本的sbt下过目文件，是；uoyi我们需要在chapter6/project文件夹下添加GoTicksBuild.scala文件。Sbt会自动merge build.sbt和GoTicksBuild.scala。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sbt._</div><div class="line"><span class="keyword">import</span> <span class="type">Keys</span>._</div><div class="line"><span class="keyword">import</span> com.typesafe.sbt.<span class="type">SbtMultiJvm</span></div><div class="line"><span class="keyword">import</span> com.typesafe.sbt.<span class="type">SbtMultiJvm</span>.<span class="type">MultiJvmKeys</span>.&#123; <span class="type">MultiJvm</span> &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">GoTicksBuild</span> <span class="keyword">extends</span> <span class="title">Build</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> buildSettings = <span class="type">Defaults</span>.defaultSettings ++ multiJvmSettings ++ <span class="type">Seq</span>(</div><div class="line">    crossPaths   := <span class="literal">false</span></div><div class="line">  )</div><div class="line"></div><div class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> goticks = <span class="type">Project</span>(</div><div class="line">    id = <span class="string">"goticks"</span>,</div><div class="line">    base = file(<span class="string">"."</span>),</div><div class="line">    settings = buildSettings ++ <span class="type">Project</span>.defaultSettings</div><div class="line">  ) configs(<span class="type">MultiJvm</span>)</div><div class="line"></div><div class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> multiJvmSettings = <span class="type">SbtMultiJvm</span>.multiJvmSettings ++ <span class="type">Seq</span>(</div><div class="line">    <span class="comment">// make sure that MultiJvm test are compiled by the default test compilation</span></div><div class="line">    compile in <span class="type">MultiJvm</span> &lt;&lt;= (compile in <span class="type">MultiJvm</span>) triggeredBy (compile in <span class="type">Test</span>),</div><div class="line">    <span class="comment">// disable parallel tests</span></div><div class="line">    parallelExecution in <span class="type">Test</span> := <span class="literal">false</span>,</div><div class="line">    <span class="comment">// make sure that MultiJvm tests are executed by the default test target</span></div><div class="line">    executeTests in <span class="type">Test</span> &lt;&lt;=</div><div class="line">      ((executeTests in <span class="type">Test</span>), (executeTests in <span class="type">MultiJvm</span>)) map &#123;</div><div class="line">        <span class="keyword">case</span> ((_, testResults), (_, multiJvmResults))  =&gt;</div><div class="line">          <span class="keyword">val</span> results = testResults ++ multiJvmResults</div><div class="line">          (<span class="type">Tests</span>.overall(results.values), results)</div><div class="line">      &#125;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你对sbt不熟，不用担心这个文件的细节。上面基本就是配置了multi-jvm插件，确认multi-jvm测试使用普通单元测试执行。要是想看看sbt的话，可以参考SBT in Action。</p>
<p>多jvm的测试默认是应该写在 src/multi-jvm/scala 文件夹下。既然我们的项目已经正确配置了，那么我们可以开始写代码测试goticks的前端和后端了。</p>
<p>首先定义MultiNodeConfig描述测试的node的角色。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClientServerConfig</span> <span class="keyword">extends</span> <span class="title">MultiNodeConfig</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> frontend = role(<span class="string">"frontend"</span>)</div><div class="line">  <span class="keyword">val</span> backend = role(<span class="string">"backend"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义了两个role。role用来确认参与测试的node运行的代码，以便于针对性的测试。在写测试之前我们需要些一些基础设施代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">STMultiNodeSpec</span> <span class="keyword">extends</span> <span class="title">MultiNodeSpecCallbacks</span></span></div><div class="line"><span class="keyword">with</span> <span class="type">WordSpec</span> <span class="keyword">with</span> <span class="type">MustMatchers</span> <span class="keyword">with</span> <span class="type">BeforeAndAfterAll</span> &#123;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">beforeAll</span></span>() = multiNodeSpecBeforeAll()</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">afterAll</span></span>() = multiNodeSpecAfterAll()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中继承MultiNodeSpecCallbacks以获取回调函数，然后下面重写了几个回调函数。</p>
<p>下面我们创建MultiNodeSpec，并让他mixin刚刚定义的STMultiNodeSpec。两个版本的ClientServerSpec会运行在不同的两个jvm上。下面是ClientServerSpec：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientServerSpecMultiJvmFrontend</span> <span class="keyword">extends</span> <span class="title">ClientServerSpec</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientServerSpecMultiJvmBackend</span> <span class="keyword">extends</span> <span class="title">ClientServerSpec</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientServerSpec</span> <span class="keyword">extends</span> <span class="title">MultiNodeSpec</span>(<span class="params"><span class="type">ClientServerConfig</span></span>)</span></div><div class="line"><span class="keyword">with</span> <span class="type">STMultiNodeSpec</span> <span class="keyword">with</span> <span class="type">ImplicitSender</span> &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 参加到这次测试的node个数</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialParticipants</span> </span>= roles.size</div></pre></td></tr></table></figure></p>
<p>ClientServerSpec使用了STMultiNodeSpec和ImplicitSender。后者设置testActor为所有message的默认sender，这样不用每次都设置了。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import后我们才可以访问到后端role</span></div><div class="line"><span class="keyword">import</span> <span class="type">ClientServerConfig</span>._</div><div class="line"></div><div class="line"><span class="comment">// 测试中使用TestRemoteBoxOfficeCreator，而不是RemoteBoxOfficeCreator</span></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TestRemoteBoxOfficeCreator</span> <span class="keyword">extends</span> <span class="title">RemoteBoxOfficeCreator</span> </span>&#123; <span class="keyword">this</span>:<span class="type">Actor</span> =&gt;</div><div class="line"></div><div class="line">  <span class="comment">// 重写方法，返回测试的path</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createPath</span></span>: <span class="type">String</span> = &#123;</div><div class="line">    <span class="keyword">val</span> actorPath = node(backend) / <span class="string">"user"</span> /<span class="string">"boxOffice"</span>		<span class="comment">//node方法返回后端role node的地址。这个表达式是创建了一个ActorPath</span></div><div class="line">    actorPath.toString</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前端和后端role node默认是在随机端口上运行。我们使用TestRemoteBoxOfficeCreator替代RemoteBoxOfficeCreator，因为后者是使用的frontend.conf文件中的配置。我们在测试中需要找的是不一样的环境。</p>
<p>看一下测试代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="string">"A Client Server configured app"</span> must &#123;</div><div class="line"></div><div class="line">    <span class="string">"wait for all nodes to enter a barrier"</span> in &#123;</div><div class="line">      enterBarrier(<span class="string">"startup"</span>) <span class="comment">// 启动所有的node</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="string">"be able to create an event and sell a ticket"</span> in &#123;</div><div class="line"></div><div class="line">      <span class="comment">// 运行在前端jvm的代码</span></div><div class="line">      runOn(frontend) &#123;</div><div class="line"> 	<span class="comment">// 等待后端发布</span></div><div class="line">        enterBarrier(<span class="string">"deployed"</span>)</div><div class="line">        <span class="comment">// 创建一个RestInterfaceMock</span></div><div class="line">	<span class="keyword">val</span> restInterface = system.actorOf(<span class="type">Props</span>(<span class="keyword">new</span> <span class="type">RestInterfaceMock</span> <span class="keyword">with</span> <span class="type">TestRemoteBoxOfficeCreator</span>))</div><div class="line"></div><div class="line">        <span class="keyword">val</span> path = node(backend) / <span class="string">"user"</span> / <span class="string">"boxOffice"</span></div><div class="line">        </div><div class="line">	<span class="comment">// 获取远程actor的actorSelection</span></div><div class="line">	<span class="keyword">val</span> actorSelection = system.actorSelection(path)</div><div class="line"></div><div class="line"> 	<span class="comment">// 向actorselection发送Identify消息</span></div><div class="line">        actorSelection.tell(<span class="type">Identify</span>(path), testActor)</div><div class="line"></div><div class="line">	<span class="comment">// 等待boxoffice汇报它是否可用。RemoteLookup类会负责获取boxoffice的ActorRef</span></div><div class="line">        <span class="keyword">val</span> actorRef = expectMsgPF() &#123;</div><div class="line">          <span class="keyword">case</span> <span class="type">ActorIdentity</span>(`path`, ref) =&gt; ref</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        restInterface ! <span class="type">Event</span>(<span class="string">"RHCP"</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">        expectMsg(<span class="type">EventCreated</span>)</div><div class="line"></div><div class="line">        restInterface ! <span class="type">TicketRequest</span>(<span class="string">"RHCP"</span>)</div><div class="line"></div><div class="line">        expectMsg(<span class="type">Ticket</span>(<span class="string">"RHCP"</span>, <span class="number">1</span>))</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 运行在后端JVM上的代码</span></div><div class="line">      runOn(backend) &#123;</div><div class="line">	<span class="comment">// 创建boxOffice，并命名为boxOffice，这样RemoteLookup就可以找到它了</span></div><div class="line">        system.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>], <span class="string">"boxOffice"</span>)</div><div class="line">	<span class="comment">// 发送后端已经部署的信号</span></div><div class="line">        enterBarrier(<span class="string">"deployed"</span>)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 测试结束</span></div><div class="line">      enterBarrier(<span class="string">"finished"</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这段测试可以分为4个部分。第一个是enterBarrier(“startup”)等待所有node启动。实际的测试会面就会指定前端和后端各自运行什么代码。前端会等后端启动成功的信号，然后执行测试。</p>
<p>后段代码只启动boxoffice，提供给前端使用。我们使用了RestInterfaceMock，TestRemoteBoxOfficeCreator。我们还是使用了RemoteLookup来等远程的actor被identify。 在发送message到远程boxoffice之前，我们先期望获得一个ActorIdentify message。</p>
<p>在项目目录下执行multi-jvm:test进行测试。</p>
<p>下图说明了测试的实际流程。<br><img src="/imgs/akka/akka_6_multi_jvm_test_flow.png" alt="Multi-JVM Test Flow"></p>
<p>单节点运行和client server 模式的最大区别就是actorRef的获取与监视。在RestInterface和boxOffice 之间添加一个Remote Lookup，获取更大的灵活性，也能够更好地处理actor挂掉的问题。我们怎样等待远程actorRef可用呢？actorSelection和Identify message机制可以搞定。</p>
<h2 id="6-3-总结"><a href="#6-3-总结" class="headerlink" title="6.3 总结"></a>6.3 总结</h2><p>记得本章开始的时候我们要分布式的理由么？</p>
<p>除了我们要做一些改变之外，还有一些不变的事情：</p>
<ul>
<li>我们使用ActorRef，不用关心它是远程actor还是本地actor</li>
<li>监控actor的API和local模式一样</li>
<li>除了协作者被网络分隔之外，我们通过中间actor，让RestInterface和BoxOffice互相通信。</li>
</ul>
<p>我们学到的新东西：</p>
<ul>
<li>REPL提供了一个简单友好的方式来探索分布式拓扑</li>
<li>multi-node-testkit使得分布式系统的测试特别简单，不管这些分布式系统是基于akka-remote还是 akka-cluster</li>
</ul>
<p>我们还没有处理在RemoteLookup和RemoteBoxOfficeForwarder的message丢失问题。下面的章节会介绍：</p>
<ul>
<li>怎样在合作node之间创建爱你可信赖的proxy</li>
<li>当后端node挂掉的时候处理TicketSellers丢失的问题</li>
<li>状态怎样在集群间复制</li>
</ul>
<p>但是。。在此之前，我们先看一下基于akka-cluster module的动态的node membership。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    

    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/akka/">akka</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/11/akka-in-action-读书笔记（5）/" title="akka in action 读书笔记（5）" itemprop="url">akka in action 读书笔记（5）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-08-11T08:35:33.000Z" itemprop="datePublished"> 发表于 2016-08-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这一章聊一下akka的Future。Actor提供了一个机制替代了并发object系统，Future提供了一个机制来替代并发function系统。</p>
<h2 id="5-1-Futrue用例"><a href="#5-1-Futrue用例" class="headerlink" title="5.1 Futrue用例"></a>5.1 Futrue用例</h2><p>Actor被用来处理message，获取state，基于收到的不同message执行不同代码。借助于监管和监控，他们成为生命力极强的对象，即便出现错误也可以继续生存。</p>
<p>Future是用来不用object，而使用function就能解决问题的工具。它是一个function结果的占位符，在未来的某一个时刻生效，是一个异步结果。</p>
<p><img src="/imgs/akka/akka_5_placeholder_for_async.png" alt="异步函数结果的占位符"></p>
<p>Future是只读的，而且可以被读多次，不能被外界修改。</p>
<p>注意：Future并不是对java.util.concurrent.Futrue的封装。后者的get方法还是会引起block的。</p>
<p>Future对于pipeline的处理方式很友好，就是经过function1的结果传递给function2使用。</p>
<p>以买票的例子来说，假设我们创建了一个web页面，提供一些额外的信息，比如天气预报、交通状况、出行计划、停车等。下面是event的处理流程：<br><img src="/imgs/akka/akka_5_chain_async_func.png" alt="异步函数链"></p>
<p>图中getEvent和getTraffic都是异步请求web服务的function，顺序执行。getTrafficInfo接收一个Event参数，当Future[Event]获得结果后就会触发getTrafficInfo的执行。这与在并发线程中执行getEvent方法等待返回结果是不同的。我们定义了一个一定会被执行的getTrafficInfo函数，而且不用任何等待。</p>
<p>下图展示了一个简单的例子：<br><img src="/imgs/akka/akka_5_aggr_result_sync_vs_async.png" alt="同步与异步的对比"></p>
<p>可见异步的话只需要花费4和2中的最长时间，而同步就需要2+4。</p>
<p>下图展示了另一个用例，利用异步最快获取天气信息：</p>
<p><img src="/imgs/akka/akka_5_weather_info_async.png" alt="异步最快获取天气信息"></p>
<p>假设X服务出现超时问题的话，就直接不用管它的结果了。</p>
<p>这些场景使用actor并不是不可以，只是直接使用actor的话会特别麻烦。假设使用actor实现上面那个获取天气和交通信息的功能，需要包含以下步骤：</p>
<p><img src="/imgs/akka/akka_5_combine_web_request_actors.png" alt="使用actor组合web请求"></p>
<p>我们需要为天气和交通服务分别创建两个actor，这样他们才能被同时调用。调用方式被定义在TicketInfo Actor中。这里也并不能实现非阻塞。</p>
<p>如果应用包含以下特性，就可以考虑使用future：</p>
<ul>
<li>不要block</li>
<li>调用一次某个function之后，在未来的某个时间点使用调用结果</li>
<li>组合许多一次调用的function结果</li>
<li>调用一些相互竞争的function，只使用其中的一部分结果，比如：最快的天气信息</li>
<li>当function出现错误的时候，需要返回默认值，以便后面的function能够继续调用</li>
<li>pipeline对结果相互依赖的function</li>
</ul>
<h2 id="5-2-Futrue中无阻塞"><a href="#5-2-Futrue中无阻塞" class="headerlink" title="5.2 Futrue中无阻塞"></a>5.2 Futrue中无阻塞</h2><p>是时候写一下TicketInfoService完成上面获取天气和交通信息了。</p>
<p>异步与同步的方法在与程序中的处理流，下面是一个同步的程序：<br><img src="/imgs/akka/akka_5_sync_call_code.png" alt="同步调用代码"></p>
<p>这里既没有使用futrue，也没有使用scala的懒加载，所以每行都需要等返回值才能继续。</p>
<p>再看一下异步的程序：<br><img src="/imgs/akka/akka_5_async_chain_call_code.png" alt="异步调用代码"></p>
<p>callEventService实际上是在另一个线程里调用的，这个线程其实是阻塞的，后面我们会解决这个问题。futrue是将一段代码进行一部执行调用的Futrue.apply的简写。</p>
<p>以上代码其实是一个闭包，把request从main线程传递给一个新的线程去执行某个方法。</p>
<p>下面把交通信息串进来：<br><img src="/imgs/akka/akka_5_async_chain_call_code.png" alt="处理异步结果，继续异步调用"></p>
<p>这段代码块只有在futrueEvent可用的时候才会执行。如果我们也需要这段程序有返回值咋办</p>
<p><img src="/imgs/akka/akka_5_async_chain_call_return_code.png" alt="返回Future[Route]"></p>
<p>也可以直接串起来。</p>
<p><img src="/imgs/akka/akka_5_async_chain_all_code.png" alt="直接串起来"></p>
<p>重构一下getEvent和getRoute方法：<br><img src="/imgs/akka/akka_5_refactor.png" alt="重构之后"></p>
<p>其实要真正的异步的话，callEventService和callTrafficService应该也是异步返回Futrue才对，这个可以借助spray-client，在后面的rest相关章节我们会介绍。</p>
<p>需要注意一个细节，就是钥匙用futrue的话需要引入对ExecutionContext的隐式转换，不然编译不过去。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Implicits</span>.global</div></pre></td></tr></table></figure></p>
<p>ExecutionContext是在某个线程池执行任务的抽象，可以类比java.util.concurrent.Executor。</p>
<p>这里介绍了成功调用的案例，下面说一下怎样从失败中恢复。</p>
<h2 id="5-3-失败"><a href="#5-3-失败" class="headerlink" title="5.3 失败"></a>5.3 失败</h2><p>假如在异步处理的过程中出现了Exception咋办？启动一个scala REPL，执行以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">scala&gt; :paste</div><div class="line">// Entering paste mode (ctrl-D to finish)</div><div class="line"></div><div class="line">import scala.concurrent._</div><div class="line">import ExecutionContext.Implicits.global</div><div class="line"></div><div class="line">val futureFail = future &#123; throw new Exception(&quot;error!&quot;)&#125;</div><div class="line">futureFail.foreach(value=&gt; println(value))</div><div class="line"></div><div class="line">// Exiting paste mode, now interpreting.</div><div class="line"></div><div class="line">futureFail: scala.concurrent.Future[Nothing] =</div><div class="line">scala.concurrent.impl.Promise$DefaultPromise@193cd8e1</div><div class="line"></div><div class="line">scala&gt;</div></pre></td></tr></table></figure></p>
<p>可以看到并没有打印我们期望的结果，命令行也没有打印方法栈。由于前面没有执行成功，所以foreach代码没有执行。</p>
<p>我们可以使用OnComplete接口<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">scala&gt; :paste</div><div class="line"><span class="comment">// Entering paste mode (ctrl-D to finish)</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> scala.util._</div><div class="line"><span class="keyword">import</span> scala.util.control.<span class="type">NonFatal</span></div><div class="line"><span class="keyword">import</span> scala.concurrent._</div><div class="line"><span class="keyword">import</span> <span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</div><div class="line"></div><div class="line"><span class="keyword">val</span> futureFail = future &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"error!"</span>)&#125;</div><div class="line">futureFail.onComplete &#123;</div><div class="line"><span class="keyword">case</span> <span class="type">Success</span>(value) =&gt; println(value)</div><div class="line"><span class="keyword">case</span> <span class="type">Failure</span>(<span class="type">NonFatal</span>(e)) =&gt; println(e)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Exiting paste mode, now interpreting.</span></div><div class="line"></div><div class="line">java.lang.<span class="type">Exception</span>: error!</div></pre></td></tr></table></figure></p>
<p>OnComplete回调函数总是会被调用，而且返回值是Unit。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">futureFail.onFailure &#123;</div><div class="line"><span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; println(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TicketInfo服务同样也应该保持一些信息，以便出现异常后记录抛出的异常信息。下图是TicketInfo里保存的事件信息：<br><img src="/imgs/akka/akka_5_accumulate_info_tickit_info.png" alt="TicketInfo保存的事件信息"></p>
<p>getEvent和getTraffic改用TicketInfo作为返回值与接收值，这样TicketInfo可以一路积攒信息，TicketInfo是一个case class。</p>
<p>注意：在使用futrue的过程中一定要全程使用不可变数据。</p>
<p>下图说明了GetTraffic调用失败的时候会发生什么：<br><img src="/imgs/akka/akka_5_ignore_failed_resp.png" alt="忽略失败的服务的response"></p>
<p>我们可以定义recover方法，当出现异常的时候就返回这个方法的返回值。下面代码说明了怎样使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> futureStep1 = getEvent(ticketNr)<span class="comment">//返回Future[TicketInfo]</span></div><div class="line"><span class="keyword">val</span> futureStep2 = futureStep1.flatMap &#123; ticketInfo =&gt; <span class="comment">// 使用flatMap我们可以直接返回Future[TicketInfo]而不是一个TicketInfo</span></div><div class="line">  getTraffic(ticketInfo).recover &#123; <span class="comment">//返回Future[TicketInfo]</span></div><div class="line">    <span class="keyword">case</span> e:<span class="type">TrafficServiceException</span> =&gt; ticketInfo <span class="comment">//使用一个包含初始TicketInfo的Future来恢复</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getTraffic啥的都是创建TicketInfo的copy。</p>
<p>还有一个recoverWith用来返回 Future[TicketInfo]而不是TicketInfo。注意上面的recover方法是同步调用的。</p>
<p>上面代码中还有一个问题，如果getEvent就失败了咋办？flatMap根本就不会执行。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> futureStep1 = getEvent(ticketNr)</div><div class="line"><span class="keyword">val</span> futureStep2 = futureStep1.flatMap &#123; ticketInfo =&gt;</div><div class="line">    getTraffic(ticketInfo).recover &#123;</div><div class="line">      <span class="keyword">case</span> e:<span class="type">TrafficServiceException</span> =&gt; ticketInfo</div><div class="line">    &#125;</div><div class="line">&#125;.recover &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; <span class="type">TicketInfo</span>(ticketNr)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果getEvent失败的话，就直接返回包含ticketNr的空TicketInfo。</p>
<h2 id="5-4-整合Futrue"><a href="#5-4-整合Futrue" class="headerlink" title="5.4 整合Futrue"></a>5.4 整合Futrue</h2><p>下面是买票服务中的所有的case class。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.goticks</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.joda.time.&#123;<span class="type">Duration</span>, <span class="type">DateTime</span>&#125;</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketInfo</span>(<span class="params">ticketNr:<span class="type">String</span>,</span></span></div><div class="line">                      userLocation:<span class="type">Location</span>,</div><div class="line">                      event:<span class="type">Option</span>[<span class="type">Event</span>]=<span class="type">None</span>,</div><div class="line">                      travelAdvice:<span class="type">Option</span>[<span class="type">TravelAdvice</span>]=<span class="type">None</span>,</div><div class="line">                      weather:<span class="type">Option</span>[<span class="type">Weather</span>]=<span class="type">None</span>,</div><div class="line">                      suggestions:<span class="type">Seq</span>[<span class="type">Event</span>]=<span class="type">Seq</span>())</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span>(<span class="params">name:<span class="type">String</span>,location:<span class="type">Location</span>, time:<span class="type">DateTime</span></span>)</span></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Artist</span>(<span class="params">name:<span class="type">String</span>, calendarUri:<span class="type">String</span></span>)</span></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Location</span>(<span class="params">lat:<span class="type">Double</span>, lon:<span class="type">Double</span></span>)</span></div><div class="line"></div><div class="line"><span class="comment">// 简单起见，所有的route都弄成了一个简单的字符串</span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteByCar</span>(<span class="params">route:<span class="type">String</span>, timeToLeave:<span class="type">DateTime</span>, origin:<span class="type">Location</span>, destination:<span class="type">Location</span>,</span></span></div><div class="line">                 estimatedDuration:<span class="type">Duration</span>, trafficJamTime:<span class="type">Duration</span>)</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PublicTransportAdvice</span>(<span class="params">advice:<span class="type">String</span>, timeToLeave:<span class="type">DateTime</span>, origin:<span class="type">Location</span>, destination:<span class="type">Location</span>,</span></span></div><div class="line">                                 estimatedDuration:<span class="type">Duration</span>)</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TravelAdvice</span>(<span class="params">routeByCar:<span class="type">Option</span>[<span class="type">RouteByCar</span>]=<span class="type">None</span>,</span></span></div><div class="line">                        publicTransportAdvice: <span class="type">Option</span>[<span class="type">PublicTransportAdvice</span>]=<span class="type">None</span>)</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span>(<span class="params">temperature:<span class="type">Int</span>, precipitation:<span class="type">Boolean</span></span>)</span></div></pre></td></tr></table></figure></p>
<p>下图是TicketInfoService的处理流：<br><img src="/imgs/akka/akka_5_ticket_flow.png" alt="TicketInfoService的处理流"></p>
<p>combinators在图中以菱形表示。所有的future最终都被整合进了Future[TicketInfo]。</p>
<p>我们以最快选取天气信息先开始讲解，下面是这块逻辑使用combinator的地方：<br><img src="/imgs/akka/akka_5_weather_flow.png" alt="天气信息流"></p>
<p>两个天气服务都返回Future[Weather]，然后我们需要的是Future[TicketInfo]。下面是代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWeather</span></span>(ticketInfo:<span class="type">TicketInfo</span>):<span class="type">Future</span>[<span class="type">TicketInfo</span>] = &#123;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> futureWeatherX = callWeatherXService(ticketInfo).recover(withNone) <span class="comment">// 恢复代码封装在withNone里了</span></div><div class="line"></div><div class="line">  <span class="keyword">val</span> futureWeatherY = callWeatherYService(ticketInfo).recover(withNone)</div><div class="line"></div><div class="line">  <span class="type">Future</span>.firstCompletedOf(<span class="type">Seq</span>(futureWeatherX, futureWeatherY)).map&#123; weatherResponse =&gt;</div><div class="line">    ticketInfo.copy(weather = weatherResponse)<span class="comment">// 复制到ticketInfo里</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>firstCompletedOf只返回第一个返回结果的服务的response，成功失败无所谓，也就是说加入先返回的是失败，那么后面即便有成功返回也不会生效了。【可以考虑firstSucceededOf】</p>
<p>下面是公共交通信息和行车路由服务，它们应该并行，然后等两者都结束调用就将结果combine进TravelAdvice。下图展示了这个combinator：<br><img src="/imgs/akka/akka_5_travel_flow.png" alt="旅行路径建议流"></p>
<p>getTraffic和getPublicTransport的Futrue各自返回一种类型数据：RouteByCar以及PublicTransportAdvice。这两个值先被放进一个tuple，然后把这个tuple map放进TravelAdvice里面。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TravelAdvice</span>(<span class="params">routeByCar:<span class="type">Option</span>[<span class="type">RouteByCar</span>]=<span class="type">None</span>,</span></span></div><div class="line">                        publicTransportAdvice: <span class="type">Option</span>[<span class="type">PublicTransportAdvice</span>]=<span class="type">None</span>)</div></pre></td></tr></table></figure></p>
<p>基于这个信息，用户就可以决定是使用公共交通工具出行，还是自驾游。下面是zip combinator的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">getTravelAdvice</span></span>(info:<span class="type">TicketInfo</span>, event:<span class="type">Event</span>):<span class="type">Future</span>[<span class="type">TicketInfo</span>] = &#123;</div><div class="line"></div><div class="line">   <span class="keyword">val</span> futureRoute = callTrafficService(info.userLocation, event.location, event.time).recover(withNone)</div><div class="line"></div><div class="line">   <span class="keyword">val</span> futurePublicTransport = callPublicTransportService(info.userLocation, event.location, event.time).recover(withNone)</div><div class="line"></div><div class="line"><span class="comment">// 先把 Future[RouteByCar] 和 Future[PublicTransportAdvice] zip成tuple放入Future[(RouteByCar, PublicTransportAdvice)]</span></div><div class="line"><span class="comment">// 然后再将这两者map放入Future[TicketInfo]</span></div><div class="line">   futureRoute.zip(futurePublicTransport).map &#123; <span class="keyword">case</span>(routeByCar, publicTransportAdvice) =&gt;</div><div class="line">     <span class="keyword">val</span> travelAdvice = <span class="type">TravelAdvice</span>(routeByCar, publicTransportAdvice)</div><div class="line">     info.copy(travelAdvice = <span class="type">Some</span>(travelAdvice))</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用for替换map，有时可读性更强一些.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>((routeByCar, publicTransportAdvice) &lt;- futureRoute.zip(futurePublicTransport);</div><div class="line">     travelAdvice = <span class="type">TravelAdvice</span>(routeByCar, publicTransportAdvice)</div><div class="line">) <span class="keyword">yield</span> info.copy(travelAdvice = <span class="type">Some</span>(travelAdvice))</div></pre></td></tr></table></figure></p>
<p>下一个部分我们看一下推荐类似活动给用户。我们使用了两个web服务，一个是类似的艺术服务，返回用户感兴趣的类似艺术的信息。使用这个信息来调用一个日历服务，以便计划下一站的去向。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回对每种艺术活动的计划列表 Future[Seq[Events]]</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSuggestions</span></span>(event:<span class="type">Event</span>):<span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">Event</span>]] = &#123;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> futureArtists = callSimilarArtistsService(event).recover(withEmptySeq) <span class="comment">// 返回类似艺术活动的列表：Future[Seq[Events]]</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span>(artists &lt;- futureArtists.recover(withEmptySeq); <span class="comment">// 'artists' evaluates at some point to a Seq[Artist]</span></div><div class="line">      events &lt;- getPlannedEvents(event, artists).recover(withEmptySeq) <span class="comment">// 'events' evaluates at some point to a Seq[Events], a planned event for every called artist.</span></div><div class="line">  ) <span class="keyword">yield</span> events</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getPlannedEvents使用Future.sequence方法把Seq[Future[Event]]构建成一个Future[Seq[Event]]作为返回值。也就是说把一串futrue放进一个futrue，这个futrue包含一串对象。下面是代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPlannedEvents</span></span>(event:<span class="type">Event</span>, artists:<span class="type">Seq</span>[<span class="type">Artist</span>]) = &#123;</div><div class="line">   <span class="keyword">val</span> events = artists.map(artist=&gt; callArtistCalendarService(artist, event.location)) <span class="comment">// events是一个 Seq[Future[Event]]</span></div><div class="line">   <span class="type">Future</span>.sequence(events) <span class="comment">// 把 Seq[Future[Event]]转为Future[Seq[Event]]。当异步调用callArtistCalendarService都完成后，就可以对futrue取值了</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>与sequence方法相似的还有一个traverse方法。下面是例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPlannedEventsWithTraverse</span></span>(event:<span class="type">Event</span>, artists:<span class="type">Seq</span>[<span class="type">Artist</span>]) = &#123;</div><div class="line">  <span class="type">Future</span>.traverse(artists) &#123; artist=&gt;  <span class="comment">// traverse方法接受一个方法块返回一个futrue对象。</span></div><div class="line">    callArtistCalendarService(artist, event.location)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用sequence的话，我们必须事先创建一个Seq[Future[Event]]，才能转化出Future[Seq[Event]]。traverse就不用什么中间步骤了。</p>
<p>终于到了TicketInfoService数据流的最后一步了。包含Weather的TicketInfo要和包含TravelAdvice的TicketInfo对象整合起来。我们使用fold方法来自完成：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ticketInfos = <span class="type">Seq</span>(infoWithTravelAdvice, infoWithWeather)</div><div class="line"></div><div class="line"><span class="keyword">val</span> infoWithTravelAndWeather = <span class="type">Future</span>.fold(ticketInfos)(info) &#123; (acc, elem) =&gt;</div><div class="line">  <span class="keyword">val</span> (travelAdvice, weather) = (elem.travelAdvice, elem.weather)</div><div class="line"></div><div class="line">  acc.copy(travelAdvice = travelAdvice.orElse(acc.travelAdvice),</div><div class="line">            weather = weather.orElse(acc.weather))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>fold方法需要一个初始值、一个方法块。集合中的每个元素都要经过这个方法块对初始值产生影响。</p>
<p>整体代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">getTicketInfo</span></span>(ticketNr:<span class="type">String</span>, location:<span class="type">Location</span>):<span class="type">Future</span>[<span class="type">TicketInfo</span>] = &#123;</div><div class="line">   <span class="keyword">val</span> emptyTicketInfo = <span class="type">TicketInfo</span>(ticketNr, location)</div><div class="line">   <span class="keyword">val</span> eventInfo = getEvent(ticketNr, location).recover(withPrevious(emptyTicketInfo))</div><div class="line"></div><div class="line">   eventInfo.flatMap &#123; info =&gt;</div><div class="line"></div><div class="line">     <span class="keyword">val</span> infoWithWeather = getWeather(info)</div><div class="line"></div><div class="line">     <span class="keyword">val</span> infoWithTravelAdvice = info.event.map &#123; event =&gt;</div><div class="line">       getTravelAdvice(info, event)</div><div class="line">     &#125;.getOrElse(eventInfo)</div><div class="line"></div><div class="line"></div><div class="line">     <span class="keyword">val</span> suggestedEvents = info.event.map &#123; event =&gt;</div><div class="line">       getSuggestions(event)</div><div class="line">     &#125;.getOrElse(<span class="type">Future</span>.successful(<span class="type">Seq</span>()))</div><div class="line"></div><div class="line">     <span class="keyword">val</span> ticketInfos = <span class="type">Seq</span>(infoWithTravelAdvice, infoWithWeather)</div><div class="line"></div><div class="line">     <span class="keyword">val</span> infoWithTravelAndWeather = <span class="type">Future</span>.fold(ticketInfos)(info) &#123; (acc, elem) =&gt;</div><div class="line">       <span class="keyword">val</span> (travelAdvice, weather) = (elem.travelAdvice, elem.weather)</div><div class="line"></div><div class="line">       acc.copy(travelAdvice = travelAdvice.orElse(acc.travelAdvice),</div><div class="line">                 weather = weather.orElse(acc.weather))</div><div class="line">     &#125;</div><div class="line"></div><div class="line"></div><div class="line">     <span class="keyword">for</span>(info &lt;- infoWithTravelAndWeather;</div><div class="line">       suggestions &lt;- suggestedEvents</div><div class="line">     ) <span class="keyword">yield</span> info.copy(suggestions = suggestions)</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 在TicketInfoService处理流中的错误恢复方法</span></div><div class="line"> <span class="class"><span class="keyword">type</span> <span class="title">Recovery</span>[<span class="type">T</span>] </span>= <span class="type">PartialFunction</span>[<span class="type">Throwable</span>,<span class="type">T</span>]</div><div class="line"></div><div class="line"> <span class="comment">// recover with None</span></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">withNone</span></span>[<span class="type">T</span>]:<span class="type">Recovery</span>[<span class="type">Option</span>[<span class="type">T</span>]] = &#123; <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; <span class="type">None</span> &#125;</div><div class="line"></div><div class="line"> <span class="comment">// recover with empty sequence</span></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">withEmptySeq</span></span>[<span class="type">T</span>]:<span class="type">Recovery</span>[<span class="type">Seq</span>[<span class="type">T</span>]] = &#123; <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; <span class="type">Seq</span>() &#125;</div><div class="line"></div><div class="line"> <span class="comment">// recover with the ticketInfo that was built in the previous step</span></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">withPrevious</span></span>(previous:<span class="type">TicketInfo</span>):<span class="type">Recovery</span>[<span class="type">TicketInfo</span>] = &#123;</div><div class="line">   <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; previous</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这段代码概括了TicketInfoService使用Futrue的逻辑。没有使用任何阻塞调用。combinator方法使这些异步掉用的结果很方便的整合起来。</p>
<h2 id="5-5-Futrue和Actor"><a href="#5-5-Futrue和Actor" class="headerlink" title="5.5 Futrue和Actor "></a>5.5 Futrue和Actor </h2><p>在前面的Up and Running 章节，我们使用Spray作为REST服务，它是使用Actor来处理HTTP 请求的，ask方法的返回值也是一个Futrue对象。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 引入ask模型，它在ActorRef上添加了ask方法</span></div><div class="line"><span class="keyword">import</span> akka.pattern.ask</div><div class="line"><span class="comment">// context包含了actor的dispatcher定义。</span></div><div class="line"><span class="keyword">import</span> context._</div><div class="line"><span class="comment">// 为ask方法必须定义一个超时</span></div><div class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> timeout = <span class="type">Timeout</span>(<span class="number">5</span> seconds)</div><div class="line"><span class="comment">// 抓获上下文中的sender</span></div><div class="line"><span class="keyword">val</span> capturedSender = sender</div><div class="line"></div><div class="line"><span class="comment">// 向TicketSeller请求GetEvents的本地方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">askEvent</span></span>(ticketSeller:<span class="type">ActorRef</span>): <span class="type">Future</span>[<span class="type">Event</span>] = &#123;</div><div class="line">   <span class="comment">// ask方法返回一个Futrue.我们使用mapTo方法将返回的Futrue[Any]转为Future[Int]。</span></div><div class="line">   <span class="keyword">val</span> futureInt = ticketSeller.ask(<span class="type">GetEvents</span>).mapTo[<span class="type">Int</span>] </div><div class="line">   </div><div class="line">   <span class="comment">// 查一下所有的子元素，对于指定event都还剩下多少票</span></div><div class="line">   futureInt.map &#123; nrOfTickets =&gt;</div><div class="line">      <span class="type">Event</span>(ticketSeller.actorRef.path.name, nrOfTickets)</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> futures = context.children.map &#123;</div><div class="line">  ticketSeller =&gt; askEvent(ticketSeller)</div><div class="line">&#125;</div><div class="line"><span class="type">Future</span>.sequence(futures).map &#123;</div><div class="line">  <span class="comment">// 给sender回送消息。这个sender就是发送原始GetEvents请求的sender。</span></div><div class="line">  events =&gt; capturedSender ! <span class="type">Events</span>(events.toList)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子比在第二章中的代码要清楚多了。每个消息的sender都不一样，这里结合闭包使用变量从context中获取当前message的sender，回送消息。</p>
<p>注意以下当在actor中使用futrue的时候，ActorContext会提供一个Actor的当前view。又由于actor是有状态的，所以闭包中的变量对于外部线程应该是不可变的。最容易达成这种效果的方式是使用不可变对象，然后在将这个值close over进futrue之前就获取这个不可变数据结构的引用，也就是上面例子中的capturedSender。</p>
<p>另一种模式是pipeTo：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//引入pipe模型</span></div><div class="line"><span class="keyword">import</span> akka.pattern.pipe</div><div class="line">path(<span class="string">"events"</span>) &#123;</div><div class="line">  get &#123; requestContext =&gt;</div><div class="line">    <span class="comment">// 创建一个actor，为所有的request使用一个response完成HTTP请求</span></div><div class="line">    <span class="keyword">val</span> responder = createResponder(requestContext)</div><div class="line">    <span class="comment">// ask方法的Futrue返回值被pipe到responder actor</span></div><div class="line">    boxOffice.ask(<span class="type">GetEvents</span>).pipeTo(responder)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Responder</span>(<span class="params">requestContext:<span class="type">RequestContext</span>,</span></span></div><div class="line">	ticketMaster:<span class="type">ActorRef</span>)</div><div class="line"> <span class="keyword">extends</span> <span class="type">Actor</span> <span class="keyword">with</span> <span class="type">ActorLogging</span> &#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="type">Events</span>(events) =&gt;</div><div class="line">        requestContext.complete(<span class="type">StatusCodes</span>.<span class="type">OK</span>, events)</div><div class="line">        self ! <span class="type">PoisonPill</span></div><div class="line"></div><div class="line">    <span class="comment">// other messages omitted..</span></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我们想用一个actor来处理futrue对象，或者某些actor的ask结果还需要进一步处理的时候，就可以使用pipeTo方法了。</p>
<h2 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h2><p>这一章介绍了一个futrue。使用futrue可以创建一个异步处理流，省去不必要的阻塞和线程等待，最大化资源使用率，最小化无作为延迟。</p>
<p>Futrue是一个function返回值的placeholder。</p>
<p>combinator方法可以方便地把futrue的值整合在一起。function可以并行执行，然后通过combinator变成一个有意义的结果。</p>
<p>futrue包含的对象应该是不可变的。</p>
<p>Futrue可以与Actor结合使用，但是要注意使用时close over的状态变量。sender的引用应该在进入闭包钱就获取。Futrue是ask方法的返回值类型，也是pipeTo方法的返回值类型。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    

    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/akka/">akka</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/09/akka-in-action-读书笔记（4）/" title="akka in action 读书笔记（4）" itemprop="url">akka in action 读书笔记（4）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-08-09T08:45:27.000Z" itemprop="datePublished"> 发表于 2016-08-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>内容提要：</p>
<ul>
<li>自救系统</li>
<li>Let it crash</li>
<li>Actor生命周期</li>
<li>Supervision</li>
<li>错误恢复策略</li>
</ul>
<h2 id="4-1-容错的来源"><a href="#4-1-容错的来源" class="headerlink" title="4.1 容错的来源"></a>4.1 容错的来源</h2><p>我们最理想的世界其实是希望系统一直可用，而且能够保证每个action都能被成功执行。只有两种方法能让这个梦想照进现实：一是使用永远不会失败的组件，二是为每次失败都提供一个完美的补救措施，这个补救措施需要能保证最终能成功完成此次action。在多数架构里，是catch住预期的异常进行处理，但是无论怎样努力都不能阻止预期之外的异常导致失败。</p>
<p>能够容忍错误的系统理论上不错，但是要同时兼顾到高可用、分布式的系统基本是不可能的。主要原因是任何此类系统的大部分我们都不能控制，这部分可能会导致失败。网络是最好的例子，它随时都有可能消失，你的系统再强大也么有用。我们显然不能让一个server从它的灰烬中恢复元气，而且自动修复前面遇到的问题。这就是let it crash 出现的原因，不去想办法回复它，而是提供足够多的可用server。</p>
<p>既然我们不能保证不发生任何失败，那么我们不得不准备一些策略：</p>
<ul>
<li>程序总会有失败。系统必须能够容错，才能继续运行其他服务。可恢复的错误不应该触发或导致灾难性的失败。</li>
<li>在某些条件允许的情况下，虽然系统的某一部分发生了问题，但是并不影响其他大部分的服务，那么我们应该切断这部分坏程序以免它产生一些不正确的结果，影响系统的其他部分正常运行。</li>
<li>一些重要的组件我们需要有备份（可以考虑放在不同的server或者使用不同的resources），当正在运行的失败的时候，能够进行热切换，使系统可用性快速恢复。</li>
<li>系统的一部分出问题不应该影响整个系统垮掉，所以我们需要一个措施来隔离某些特殊的失败，且需要在这些失败发生之后有处理措施。</li>
</ul>
<p>当然，akka并没有容错的银弹。我们还是要处理失败，但是我们可以使用一种cleaner,more application-specifc的方式来处理。下面是Akka关于容错的一些特性：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fault containment or isolation</td>
<td>一个fault应该是系统的一部分，不应导致整体crash</td>
</tr>
<tr>
<td>Structure</td>
<td>隔离某个失败的组件意味着需要某个结构来实施隔离，系统需要一个定义好的Structure，把可以被隔离的部分放进去</td>
</tr>
<tr>
<td>冗余</td>
<td>当一个组件失败之后，应该有备份的替代它</td>
</tr>
<tr>
<td>替代</td>
<td>如果一个失败的组件可以被隔离，我们也可以在Structure中替换掉它。</td>
</tr>
<tr>
<td>重启</td>
<td>如果一个组件出现了不正确的状态，我们应该能够把它重新初始化。不正确的那个state或许就是导致错误的原因</td>
</tr>
<tr>
<td>组件生命周期</td>
<td>一个失败的组件必须被隔离，如果它不能恢复的话，就必须被终结和移除，或者重新处理化它的state。有些必要的周期：start, restart, terminate</td>
</tr>
<tr>
<td>暂停</td>
<td>当一个组件失败了，我们应该在它被修复之前把所有对它的调用都弄成suspended。这些调用应该保留下来，用来分析当前组件失败的原因</td>
</tr>
<tr>
<td>Separation of Concerns 分散关注</td>
<td>如果容错代码能够与普通执行代码分割开就最好了。在普通的流程当中，容错算是横向切入的了。把普通流程与容错恢复流程分离开会简化我们的工作</td>
</tr>
</tbody>
</table>
<p>有人或许会问，用普通的异常捕捉机制就不能搞这套东西么？普通的异常是用来回退一系列操作来保证数据一致性的。但是既然提到了，我们还是用下面的部分来讨论一下。</p>
<h5 id="4-1-1-普通异常方式"><a href="#4-1-1-普通异常方式" class="headerlink" title="4.1.1 普通异常方式"></a>4.1.1 普通异常方式</h5><p>假设有这样一个应用： 多线程，收集log，从文件中分析有兴趣的信息，然后转存为行对象，然后把这些行写入某个数据库。有一些file watcher进程持续盯着增长的文件，然后通知多个线程来处理新的文件。下图是一个概览：</p>
<p><img src="/imgs/akka/akka_4_process_logs_app.png" alt="应用概览"></p>
<p>如果数据库连接断了的话，我们期望切换到另一个数据库继续写数据，而不是回滚。如果连接开始出现问题，我们或许希望马上停掉它，以免app的其他部分使用它。有时我们只要重启这个连接，摆脱这个连接内某些错误的状态就可以了。可以用伪代码看一下潜在的问题区域。先看一下使用标准的异常处理方法直接在同一个数据库上重启一个新的连接。</p>
<p>首先，多线程里都已经准备好了要入库的数据。下图是创建writer：</p>
<p><img src="/imgs/akka/akka_4_create_writer.png" alt="创建DB writer"></p>
<p>writer的依赖是通过构造方法传入的，数据库工厂的配置，都通过创建爱你writer的thread传入。下一步，我们准备log processor。每个processor都有一个writer的引用，用来存储行数据。如下图：</p>
<p><img src="/imgs/akka/akka_4_create_log_processor.png" alt="创建log processor"></p>
<p>方法的调用栈如下图：</p>
<p><img src="/imgs/akka/akka_4_call_stack.png" alt="处理log文件的方法调用栈"></p>
<p>上图流程是被多线程同时调用的。下图战士了当一个DbBrokenConnectionException被跑出的时候的调用栈，这个异常暗示我们需要切换到另一个连接。</p>
<p><img src="/imgs/akka/akka_4_call_stack_log.png" alt="处理log文件的调用栈"></p>
<p>除了直接向上跑出异常之外，我们期望从DbBrokenConnectionException恢复，替换掉不能使用的连接。我们面临的第一个问题是很难在不打破既有设计的前提下添加代码去恢复连接。另外，我们没有足够的信息来重建连接：我们不知道我们已经成功处理到文件的哪一行了，在处理哪一行时出现的异常。</p>
<p>如果让我们执行的行数和连接信息对所有对象都可见的话，就打破了我们的简单性原则，而且违背了一些基本的实践：封装、控制反转、单一职则。我们只是需要把失败的组件替换掉而已。直接在异常处理中添加恢复的代码会混淆执行log文件的功能性。即便我们找到替换连接的方式，我们还不得不着重注意替换连接的时候，其他的线程没有在使用它，不然可能导致某些行数据丢失。</p>
<p>还有，让多线程之间针对某个异常进行沟通本来也不是什么标准特性，你必须要自己实现它。回顾容错的必备特性，想一下这种处理方式有么有可能站住脚：</p>
<ul>
<li>错误隔离。许多线程都可以同时抛出异常，所以隔离相当困难。我们必须得加些锁才行。</li>
<li>Structure。必须自己创建</li>
<li>冗余。 异常不断被抛往上一层。或许会丢失掉一些重要的信息。</li>
<li>替换。 没有默认的策略支持在调用栈中替换一个对象，你必须得自己想个办法。有些依赖注入的框架支持这个特性，但是只是在特别简单的直接引用到旧的实例的时候。还有就是如果你要替换某个对象的时候，最好考虑好多线程问题。</li>
<li>重启。</li>
<li>组件生命周期。</li>
<li>暂停</li>
<li>关注分离。异常处理代码和业务代码混淆在一起，么有独立性。</li>
</ul>
<p>简述以下主要的问题：</p>
<ul>
<li>在first-class中，重新创建对象以及他们的依赖，在app中替换掉他们是不可能的 </li>
<li>直接相互沟通的对象很难隔离</li>
<li>容错代码和功能代码混淆在一起</li>
</ul>
<p>回头看看Akka。 Actor可以有Props对象重建，是actor system的一部分，actor之间通过actorRef进行沟通。下面我们看一下actor怎样把功能代码和容错代码分离，actor的生命周期怎样保证actor的暂停和重启。</p>
<h5 id="4-1-2-Let-it-crash"><a href="#4-1-2-Let-it-crash" class="headerlink" title="4.1.2 Let it crash"></a>4.1.2 Let it crash</h5><p>前面介绍了使用普通对象和异常处理机制来构建一个容错系统有多难，下面我们展示以下Actor的风采。</p>
<p>akka的容错恢复代码与功能代码是分开的。功能流包含处理普通message的actor，恢复流包含监控功能流中actor的actor。这种监控其他actor的actor叫做supervisor，如下图：</p>
<p><img src="/imgs/akka/akka_4_normal_recovery_flows.png" alt="功能流和恢复流"></p>
<p>actor中并不捕获异常，就直接让actor挂掉就性了。actor代码中只包含功能处理，而且没有异常处理逻辑或者恢复逻辑，不参与恢复过程，这样就清晰多了。crashed actor的mailbox在恢复流里的supervisor处理完exception之前都是暂停的。那么一个actor怎样才能变成一个supervisor呢？akka有一个父监管的机制，就是创建actor的actor自动成为被创建actor的supervisor。一个supervisor并不捕获异常，也不修复actor或者actor的状态，只负责判断怎样恢复，然后触发相应的策略。supervisor有4种策略：</p>
<ul>
<li>restart。使用失败actor的Props重建一个actor。这个新的actor重启之后，就继续处理消息。因为app的其他部分都是使用ActorRef来跟actor沟通，新的actor实例可以自动获取到下一条message。</li>
<li>resume。给当前actor新生，假装啥都没发生</li>
<li>stop。终结actor。</li>
<li>escalate。supervisor不知道怎样处理这个问题，抛给它的supervisor。</li>
</ul>
<p>下图是针对log处理系统的一个示例：</p>
<p><img src="/imgs/akka/akka_4_normal_recovery_flows_akka.png" alt="log处理系统中的功能流与恢复流"></p>
<p>上图中给出的容错方案是，当DbBrokenConnectionException发生的时候，使用restart策略，替换一个重建的dbWriter actor。</p>
<p>多数情况下，我们不希望重复执行那条导致失败的信息。比如logprocessor遇到一个损坏的文件，这导致mailbox走火入魔，任何message都不会被处理了，因为这个损坏的文件导致我们一次又一次的失败。鉴于此，如果是akka默认对于restart策略处理的actor，不再把处理失败的message放回mailbox了，如果不想这样，后面我们会说一下怎样做。</p>
<p>下图展示了当supervisor选择restart策略后，一个挂掉的dbWriter actor实例怎样被一个新的实例替换掉：</p>
<p><img src="/imgs/akka/akka_4_restart_handle_exception.png" alt="使用restart处理DbBrokenConnectionException异常"></p>
<p>结合容错性，说一下let it crash的好处：</p>
<ul>
<li>错误隔离。supervisor可以决定是否终结actor。</li>
<li>Structure。 actor system的actorRef层级使得在不影响其他actor的前提下替换actor实例</li>
<li>冗余。一个actor可以被另一个替换掉。在断掉的数据库连接例子中，新的actor实例可以连接到不同的数据库。supervisor也可以决定停掉错误的actor创建另一种类型的actor。另外还可以把message路由给一个负载均衡的actor集群中，后面第八章我们会讲到。</li>
<li>替换。actor总是可以被它的Props重建。supervisor不用了解重建actor的任何细节。</li>
<li>重启。通过restart实现</li>
<li>组件生命周期。actor是一个active component。可以被启动，停止，重启。下一节我们会讨论actor的生命周期。</li>
<li>暂停。当actor挂掉的时候，它的mailbox就暂停了，直到supervisor处理完毕。</li>
<li>关注隔离。负责功能的actor与负责容错的actor已经隔离开了。</li>
</ul>
<h2 id="4-2-Actor生命周期"><a href="#4-2-Actor生命周期" class="headerlink" title="4.2 Actor生命周期"></a>4.2 Actor生命周期</h2><p>actor在创建之后就自动启动了。在被停止之前，actor一直保持在Started state。停止之后的state是Terminated，这时actor就不能处理message了，而且会被GC回收。当state是Started的时候，它既可以被重启也可以设置它的state为其他值。</p>
<p>一个actor的生命周期中有三种类型的event发生：</p>
<ul>
<li>被创建和启动，Start</li>
<li>被重启，Restart</li>
<li>被停止，Stop</li>
</ul>
<p>在Actor trait中有几个hook对应这生命周期的改变。我们可以在这些hook里添加自己的代码，用来为新建的actor指定一些自定义的state，也可以在restart之前处理前面处理失败的message，还可以清空某些资源占用。下面我们看看这三种event，并了解一下hook的重写。</p>
<h4 id="4-2-1-Start事件"><a href="#4-2-1-Start事件" class="headerlink" title="4.2.1 Start事件"></a>4.2.1 Start事件</h4><p>一个普通的actor是通过actorOf方法创建并启动的。顶层actor是被ActorSystem的actorOf方法床架难点。父actor通过自身的ActorContext的actorOf方法创建子actor。</p>
<p><img src="/imgs/akka/akka_4_start_actor.png" alt="启动一个actor"></p>
<p>实例创建好之后，就会被Akka启动。preStart hook是在actor启动之前被调用的。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>() &#123;</div><div class="line">	println(<span class="string">"preStart"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般这个hook可以用来设置actor的初始状态。</p>
<h4 id="4-2-2-Stop事件"><a href="#4-2-2-Stop事件" class="headerlink" title="4.2.2 Stop事件"></a>4.2.2 Stop事件</h4><p>actor通常通过调用ActorSystem和ActorContext对象的stop方法停止，或者发送一个PosionPill message给它。</p>
<p><img src="/imgs/akka/akka_4_stop_actor.png" alt="停止actor"></p>
<p>postStop hook与preStart对称，在actor被终结之前，state被修改为Terminated之后调用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>()&#123;</div><div class="line">	println(<span class="string">"postStop"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般用来释放资源，或者保存当前actor处理的一些信息到actor外界，以便新的actor实例可以使用。stopped actor和它的ActorRef会断开连接。ActorRef会被重定向到actor system的deadLetters ActorRef，这个ActorRef专门用来接收发送给挂了的actor的message。</p>
<h4 id="4-2-3-Restart事件"><a href="#4-2-3-Restart事件" class="headerlink" title="4.2.3 Restart事件"></a>4.2.3 Restart事件</h4><p><img src="/imgs/akka/akka_4_restart_actor.png" alt="重启actor"></p>
<p>restart发生后，触发挂掉的actor的preRestart方法。在这个hook中挂掉的actor实例可以储存它当前的一些状态信息。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preRestart</span></span>(reason: <span class="type">Throwable</span>, <span class="comment">// 被当前actor跑出的异常</span></div><div class="line">                         message: <span class="type">Option</span>[<span class="type">Any</span>]) &#123; <span class="comment">//导致错误的message</span></div><div class="line">   println(<span class="string">"preRestart"</span>)</div><div class="line">   <span class="keyword">super</span>.preRestart(reason, message) <span class="comment">//警告：这是调用super的实现</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>重写这个hook的时候需要额外注意。默认的preRestart实现是先停止所有的子actor，然后再调用postStop hook。如果忘记调用super.preRestart方法，刚才提到的默认逻辑就不会执行了。记住actor是由Props创建的。Props对象其实是调用的actor的构造方法。actor可以在它的构造方法中创建子actor。如果挂掉的actor的子actor没有被停掉，那么后面随着父actor的多次restart，会有很多的子actor，就泛滥了。</p>
<p>注意restart和stop停掉actor 的方式是不一样的。在restart中挂掉的actor实例不会产生Terminated message。新的actor实例在restar期间就连接到了原来的ActorRef上。而stoped事件中stopped actor要将message重定向。两者相同的是在挂掉的actor被切离actor system之后都会调用postStop。</p>
<p>保存state的方式：可以给自己的mailbox发一条message，也可以存在类似DB的介质中。</p>
<p>调用完preStart hook之后，一个actor实例就被创建了。在postRestart hook被调用后。。。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postRestart</span></span>(reason: <span class="type">Throwable</span>) &#123; <span class="comment">//当前actor抛出的异常</span></div><div class="line">  println(<span class="string">"postRestart"</span>)</div><div class="line">  <span class="keyword">super</span>.postRestart(reason) <span class="comment">//警告：调用super实现</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里也有个警告，就是调用父级实现，它会触发preStart方法的执行。如果你确认不需要调用preStart方法，就不用调用这个父级实现了。</p>
<h4 id="4-2-4-把生命周期整合起来"><a href="#4-2-4-把生命周期整合起来" class="headerlink" title="4.2.4 把生命周期整合起来"></a>4.2.4 把生命周期整合起来</h4><p>把上面所有的event结合起来就是actor的整体生命周期了，下图只展示了一个restart：<br><img src="/imgs/akka/akka_4_full_life.png" alt="actor的整体生命周期"></p>
<p>对应整体生命周期的hook代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> aia.faulttolerance</div><div class="line"></div><div class="line"><span class="keyword">import</span> akka.actor._</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeCycleHooks</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> </span>&#123;</div><div class="line">  println(<span class="string">"Constructor"</span>)</div><div class="line">  <span class="comment">//&lt;start id="ch3-life-start"/&gt;</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>() &#123;</div><div class="line">    println(<span class="string">"preStart"</span>) <span class="comment">//&lt;co id="ch3-life-start-1" /&gt;</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//&lt;end id="ch3-life-start"/&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">//&lt;start id="ch3-life-stop"/&gt;</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>() &#123;</div><div class="line">    println(<span class="string">"postStop"</span>) <span class="comment">//&lt;co id="ch3-life-stop-1" /&gt;</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//&lt;end id="ch3-life-stop"/&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">//&lt;start id="ch3-life-pre-restart"/&gt;</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preRestart</span></span>(reason: <span class="type">Throwable</span>, <span class="comment">//&lt;co id="ch3-life-pre-restart-1a" /&gt;</span></div><div class="line">                          message: <span class="type">Option</span>[<span class="type">Any</span>]) &#123; <span class="comment">//&lt;co id="ch3-life-pre-restart-1b" /&gt;</span></div><div class="line">    println(<span class="string">"preRestart"</span>)</div><div class="line">    <span class="keyword">super</span>.preRestart(reason, message) <span class="comment">//&lt;co id="ch3-life-pre-restart-2" /&gt;</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//&lt;end id="ch3-life-pre-restart"/&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">//&lt;start id="ch3-life-post-restart"/&gt;</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postRestart</span></span>(reason: <span class="type">Throwable</span>) &#123; <span class="comment">//&lt;co id="ch3-life-post-restart-1" /&gt;</span></div><div class="line">    println(<span class="string">"postRestart"</span>)</div><div class="line">    <span class="keyword">super</span>.postRestart(reason) <span class="comment">//&lt;co id="ch3-life-post-restart-2" /&gt;</span></div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//&lt;end id="ch3-life-post-restart"/&gt;</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"restart"</span> =&gt;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"force restart"</span>)</div><div class="line">    <span class="keyword">case</span> msg: <span class="type">AnyRef</span> =&gt;</div><div class="line">      println(<span class="string">"Receive"</span>)</div><div class="line">      sender() ! msg</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面测试一下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> aia.faulttolerance</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.scalatest.&#123;<span class="type">WordSpecLike</span>, <span class="type">BeforeAndAfterAll</span>&#125;</div><div class="line"><span class="keyword">import</span> akka.testkit.<span class="type">TestKit</span></div><div class="line"><span class="keyword">import</span> akka.actor._</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeCycleHooksTest</span> <span class="keyword">extends</span> <span class="title">TestKit</span>(<span class="params"><span class="type">ActorSystem</span>("<span class="type">LifCycleTest</span>"</span>)) <span class="keyword">with</span> <span class="title">WordSpecLike</span> <span class="keyword">with</span> <span class="title">BeforeAndAfterAll</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">afterAll</span></span>() &#123;</div><div class="line">    system.terminate()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="string">"The Child"</span> must &#123;</div><div class="line">    <span class="string">"log lifecycle hooks"</span> in &#123;</div><div class="line">      <span class="comment">//&lt;start id="ch3-life-test"/&gt;</span></div><div class="line">      <span class="keyword">val</span> testActorRef = system.actorOf( <span class="comment">//&lt;co id="ch3-life-test-start" /&gt;</span></div><div class="line">        <span class="type">Props</span>[<span class="type">LifeCycleHooks</span>], <span class="string">"LifeCycleHooks"</span>)</div><div class="line">      testActorRef ! <span class="string">"restart"</span> <span class="comment">//&lt;co id="ch3-life-test-restart" /&gt;</span></div><div class="line">      testActorRef.tell(<span class="string">"msg"</span>, testActor)</div><div class="line">      expectMsg(<span class="string">"msg"</span>)</div><div class="line">      system.stop(testActorRef) <span class="comment">//&lt;co id="ch3-life-test-stop" /&gt;</span></div><div class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</div><div class="line">      <span class="comment">//&lt;end id="ch3-life-test"/&gt;</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-2-5-生命周期监控"><a href="#4-2-5-生命周期监控" class="headerlink" title="4.2.5 生命周期监控"></a>4.2.5 生命周期监控</h4><p>ActorContext的watch方法负责监控actor的死亡，unwatch方法反注册某个actor。一旦一个actor调用了某个ActorRef的watch方法，他就被这个ActorRef监控了。当被监控的actor被终结后，监控的actor会收到一个Terminated message，这个message只包含挂掉的actor的ActorRef。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> aia.faulttolerance</div><div class="line"></div><div class="line"><span class="keyword">import</span> akka.actor._</div><div class="line"><span class="keyword">import</span> akka.actor.<span class="type">Terminated</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">DbStrategy2</span> </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">DbWatcher</span>(<span class="params">dbWriter: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> </span>&#123;</div><div class="line">    context.watch(dbWriter) <span class="comment">//watch dbWriter的生命周期</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Terminated</span>(actorRef) =&gt; <span class="comment">//被终结的actor的actorRef被放在Terminated message中传递</span></div><div class="line">        log.warning(<span class="string">"Actor &#123;&#125; terminated"</span>, actorRef) <span class="comment">//监控者打印出dbWriter被终结的消息</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//&lt;end id="ch03-termination"/&gt;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与supervisor只能是父actor对子actor不同，actor之间的监控是没有任何规则的。只要某个actor可以访问到被监控actor的ActorRef，那么它就可以调用context.watch(actorRef)进行监控。监控(monitor)与监管(supervisor)联合起来使用会有特别强大的效果，下一节我们会介绍。</p>
<h2 id="4-3-监管"><a href="#4-3-监管" class="headerlink" title="4.3 监管"></a>4.3 监管</h2><p>这一节我们继续以log处理app为例，深入看一下监管的细节处理。这一节我们关注一下<code>用户空间</code>也就是actor path为/user下的监管层级。这个actor path是所有app的actor的家。/user之外的path我们会在actor system关闭过程中涉及到。首先我们先看一下为某个app定义supervisor的层级的几种方式，对比一下优缺点。然后看一下怎样在supervisor中自定义监管策略。</p>
<h4 id="4-3-1-监管层级"><a href="#4-3-1-监管层级" class="headerlink" title="4.3.1 监管层级"></a>4.3.1 监管层级</h4><p>actor在被创建的时候就注定了由它的创建者actor监管。父actor只有终结它的子actor才能接触这种监管关系。所在在app启动的时候就需要慎重考虑监管策略，尤其是不想整批整批的替换子actor的时候。</p>
<p>actor所处的层级越高，危险性越大。极端情况，顶层actor出现错误的话，整个系统的所有actor都需要重启。</p>
<p>下图展示了supervisor和actor之间的沟通，以及一个新的文件产生到存储入数据库的信息流：</p>
<p><img src="/imgs/akka/akka_4_message_flow_supervisor.png" alt="supervisor分离与信息流"></p>
<p>图中可以看到fileWatcherSupervisor同时创建了fileWatcher和logProcessorsSupervisor。fileWatcher需要一个logProcessor的关联对象，而这个logProcessor是由logProcessorsSupervisor创建的，所以我们不能直接给fileWatcher一个ActorRef。我们不得不添加一些信息，发送给logProcessorsSupervisor，向它请求logProcessor的ActorRef，然后把ActorRef转给fileWatcher。</p>
<p>这种方法的好处是actor之间可以之间沟通，supervisor只负责监管与创建actor实例。缺点是我们之恩那个使用restart策略，否则message就会被发送给deadLetters，丢失掉。父监管模式使得监管从信息流中解耦有些难。logProcessor只能被logProcessorsSupervisor创建，这样就很难传递它的ActorRef给fileWatcher。</p>
<p>下一幅图是另一种实现方式。supervisor不只是创建和监管actor，它们还负责传递消息流给它的子actor。对于被监管的actor来说没有改变什么，因为真正的发送者是透明的。比如logProcessor会认为他的message是从fileWatcher获取的，但是实际上logProcessorSupervisor参与了这个message的转发。</p>
<p><img src="/imgs/akka/akka_4_supervisor_forward_message.png" alt="supervisor转发消息流"></p>
<p>这种方式的好处是间接提供了层级。supervisor可以在其他actor不知情的前提下终结或者扩张它的子actor。相比前面的方式，这种方式不会出现信息流断裂的情况。这种方案更适合父监管模式，因为supervisor可以直接使用Props对象创建它的子actor。比如fileWatcherSupervisor可以直接使用它创建的logProcessingSupervisor的ActorRef去创建fileWatcher。以下是实现代码：</p>
<p><img src="/imgs/akka/akka_4_supervisor_hierarchy_code.png" alt="监管层级实现代码"></p>
<p>Props对象在actor之间来回传递，它包含了创建子actor所需要的依赖信息，这样每个actor在创建子actor的时候就不用关心细节了。最顶层的actor是由<code>system.actorFor</code>方法创建爱你的，因为我们想让系统中其他由supervisor创建的actor都沿着它这条发源地走下去。下一节我们会了解一下创建actor的具体过程：主要就是使用Props对象，调用<code>context.actorOf(props)</code>方法创建一个子actor，然后把当前actor作为每个新生actor的supervisor。</p>
<h4 id="4-3-2-预订义监管策略"><a href="#4-3-2-预订义监管策略" class="headerlink" title="4.3.2 预订义监管策略"></a>4.3.2 预订义监管策略</h4><p>创建app的顶层actor的是/user路径，它被<code>user guardian</code>监管。user guardian的默认监管策略是一旦发生异常，就直接重启它的子actor。actor的默认监管策略可以通过实现supervisorStrategy方法进行重写。在supervisorStrategy中有两个预订义的监管策略：defaultStrategy和stoppingStrategy。顾名思义，前者是所有的actor的默认监管策略，如果不重写的话，就一直使用这个策略：<br><img src="/imgs/akka/akka_4_default_strategy.png" alt="默认监管策略"></p>
<ul>
<li>Decider对异常模式匹配选择一个Directive</li>
<li>Directive包含：Stop, Start, Resume, Escalate这几种</li>
<li>defaultDecider返回OneForOneStrategy</li>
</ul>
<p>有时我们只需要停掉出错的actor，有时一旦有一个子actor出错我们就需要停掉所有的子actor。OneForOneStrategy代表这子actor不会有相同的命运，只有挂掉的子actor会被Decider裁决。还有AllForOneStrategy，他就是只要有一个子actor出问题，所有的子actor就都需要遭受裁决。</p>
<p>下图是stoppingStrategy的代码：<br><img src="/imgs/akka/akka_4_stopping_strategy.png" alt="stoppingStrategy代码"></p>
<p>发生任何异常stoppingStrategy都会停掉所有的子actor。如果不是发生Exception，而是Error呢？任何监管策略处理不了的Throwable都会向上抛给当前actor的父supervisor，抛到最顶层，也就是user guardian那里还处理不了的话就会导致整个actor system挂掉。</p>
<h4 id="4-3-3-自定义策略"><a href="#4-3-3-自定义策略" class="headerlink" title="4.3.3 自定义策略"></a>4.3.3 自定义策略</h4><p>每个app为了容错都需要定义一些自己的策略。前面我们提到一个supervisor对待挂掉的actor有四种处理措施，下面我们还是以log处理app来举例。</p>
<ol>
<li>Resume。 忽略错误，使用现在的actor继续执行message</li>
<li>Restart。 移除挂掉的actor实例，使用新的actor实例替换它</li>
<li>Stop。 永久终结这个actor</li>
<li>Escalate。 把失败报给自己的supervisor，让自己的父actor去处理。</li>
</ol>
<p>首先看一下在log处理app中可能出现的异常。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SerialVersionUID</span>(<span class="number">1</span>L)</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">DiskError</span>(<span class="params">msg: <span class="type">String</span></span>)</span></div><div class="line">    <span class="keyword">extends</span> <span class="type">Error</span>(msg) <span class="keyword">with</span> <span class="type">Serializable</span> <span class="comment">//当硬盘挂掉导致资源不可用时的一个不可恢复的Error</span></div><div class="line"></div><div class="line">  <span class="meta">@SerialVersionUID</span>(<span class="number">1</span>L)</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CorruptedFileException</span>(<span class="params">msg: <span class="type">String</span>, val file: <span class="type">File</span></span>)</span></div><div class="line">    <span class="keyword">extends</span> <span class="type">Exception</span>(msg) <span class="keyword">with</span> <span class="type">Serializable</span> <span class="comment">//日志文件损坏造成的Exception</span></div><div class="line"></div><div class="line">  <span class="meta">@SerialVersionUID</span>(<span class="number">1</span>L)</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">DbBrokenConnectionException</span>(<span class="params">msg: <span class="type">String</span></span>)</span></div><div class="line">    <span class="keyword">extends</span> <span class="type">Exception</span>(msg) <span class="keyword">with</span> <span class="type">Serializable</span> <span class="comment">//数据库连接断开的Exception</span></div></pre></td></tr></table></figure></p>
<p>actor之间发送的message可以放在一个protocol对象中统一管理。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  <span class="class"><span class="keyword">object</span> <span class="title">LogProcessingProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// represents a new log file</span></div><div class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFile</span>(<span class="params">file: <span class="type">File</span></span>) <span class="title">//从fileWatcher接收到一个log文件。log</span> <span class="title">processor要处理这个message</span></span></div><div class="line">    <span class="comment">// A line in the log file parsed by the LogProcessor Actor</span></div><div class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Line</span>(<span class="params">time: <span class="type">Long</span>, message: <span class="type">String</span>, messageType: <span class="type">String</span></span>) <span class="title">//LogFile里的一行数据。数据库的writer需要将这个数据写到数据库连接里</span></span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先从最底层看一下可能出现DbBrokenConnectionException的dbWriter。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbWriter</span>(<span class="params">databaseUrl: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line">    <span class="keyword">val</span> connection = <span class="keyword">new</span> <span class="type">DbCon</span>(databaseUrl)</div><div class="line"></div><div class="line">    <span class="keyword">import</span> <span class="type">LogProcessingProtocol</span>._</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Line</span>(time, message, messageType) =&gt;</div><div class="line">        connection.write(<span class="type">Map</span>(<span class="symbol">'time</span> -&gt; time,</div><div class="line">          <span class="symbol">'message</span> -&gt; message,</div><div class="line">          <span class="symbol">'messageType</span> -&gt; messageType)) <span class="comment">//向数据库写数据就可能引发这个异常</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>DbWriter是由DbSupervisor监管的，前面说到DbSupervisor会把所有的message转发给dbWriter。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbSupervisor</span>(<span class="params">writerProps: <span class="type">Props</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">supervisorStrategy</span> </span>= <span class="type">OneForOneStrategy</span>() &#123;</div><div class="line">      <span class="keyword">case</span> _: <span class="type">DbBrokenConnectionException</span> =&gt; <span class="type">Restart</span> <span class="comment">//发生DbBrokenConnectionException的时候执行Restart策略</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> writer = context.actorOf(writerProps) <span class="comment">//supervisor使用一个Props对象创建dbWriter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">      <span class="keyword">case</span> m =&gt; writer forward (m) <span class="comment">//supervisor把收到的所有的message转发给dbWriter ActorRef</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>再向上一些，就是logProcessor。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogProcessor</span>(<span class="params">dbSupervisor: <span class="type">ActorRef</span></span>)</span></div><div class="line">  <span class="keyword">extends</span> <span class="type">Actor</span> <span class="keyword">with</span> <span class="type">LogParsing</span> &#123;</div><div class="line">  <span class="keyword">import</span> <span class="type">LogProcessingProtocol</span>._</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">LogFile</span>(file) =&gt;</div><div class="line">      <span class="keyword">val</span> lines = parse(file) <span class="comment">//读取文件就可能引发异常，导致当前actor挂掉</span></div><div class="line">      lines.foreach(dbSupervisor ! _) <span class="comment">//把文件的每一行都发送给dbSupervisor</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当出现文件损坏问题的时候，它的supervisor采取措施如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogProcSupervisor</span>(<span class="params">dbSupervisorProps: <span class="type">Props</span></span>)</span></div><div class="line">  <span class="keyword">extends</span> <span class="type">Actor</span> &#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">supervisorStrategy</span> </span>= <span class="type">OneForOneStrategy</span>() &#123;</div><div class="line">    <span class="keyword">case</span> _: <span class="type">CorruptedFileException</span> =&gt; <span class="type">Resume</span> <span class="comment">//出现CorruptedFileException.的时候，跳过损坏的文件，继续执行</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">val</span> dbSupervisor = context.actorOf(dbSupervisorProps) <span class="comment">//创建database的supervisor，而且被当前supervisor监管</span></div><div class="line">  <span class="keyword">val</span> logProcProps = <span class="type">Props</span>(<span class="keyword">new</span> <span class="type">LogProcessor</span>(dbSupervisor))</div><div class="line">  <span class="keyword">val</span> logProcessor = context.actorOf(logProcProps) <span class="comment">//通过Props创建logProcessor</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">    <span class="keyword">case</span> m =&gt; logProcessor forward (m) <span class="comment">//把所有的message都转发给logProcessor ActorRef</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再向上一个层级，FileWatcher:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileWatcher</span>(<span class="params">sourceUri: <span class="type">String</span>,</span></span></div><div class="line">                    logProcSupervisor: <span class="type">ActorRef</span>)</div><div class="line">    <span class="keyword">extends</span> <span class="type">Actor</span> <span class="keyword">with</span> <span class="type">FileWatchingAbilities</span> &#123;</div><div class="line">    register(sourceUri) <span class="comment">//使用file的watching API注册监听文件变化</span></div><div class="line">    <span class="keyword">import</span> <span class="type">FileWatcherProtocol</span>._</div><div class="line">    <span class="keyword">import</span> <span class="type">LogProcessingProtocol</span>._</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">NewFile</span>(file, _) =&gt; <span class="comment">//利用file watching API，当发现新文件的时候发送出去</span></div><div class="line">        logProcSupervisor ! <span class="type">LogFile</span>(file) <span class="comment">//发送给logProcSupervisor</span></div><div class="line">      <span class="keyword">case</span> <span class="type">SourceAbandoned</span>(uri) <span class="keyword">if</span> uri == sourceUri =&gt;</div><div class="line">        self ! <span class="type">PoisonPill</span> <span class="comment">//如果出现硬盘损坏问题，fileWatcher就自杀</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>fileWatcher这个actor自杀之后，由于DiskError没有被定义处理策略，所以就会自动向上传递。这是一个不可恢复的error，所以FileWatchingSupervisor决定停止所有的actor，使用了AllForOneStrategy：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileWatcherSupervisor</span>(<span class="params">sources: <span class="type">Vector</span>[<span class="type">String</span>],</span></span></div><div class="line">                               logProcSuperProps: <span class="type">Props</span>)</div><div class="line">    <span class="keyword">extends</span> <span class="type">Actor</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> fileWatchers: <span class="type">Vector</span>[<span class="type">ActorRef</span>] = sources.map &#123; source =&gt;</div><div class="line">      <span class="keyword">val</span> logProcSupervisor = context.actorOf(logProcSuperProps)</div><div class="line">      <span class="keyword">val</span> fileWatcher = context.actorOf(<span class="type">Props</span>(</div><div class="line">        <span class="keyword">new</span> <span class="type">FileWatcher</span>(source, logProcSupervisor)))</div><div class="line">      context.watch(fileWatcher) <span class="comment">//对filewatcher实施监控</span></div><div class="line">      fileWatcher</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">supervisorStrategy</span> </span>= <span class="type">AllForOneStrategy</span>() &#123;</div><div class="line">      <span class="keyword">case</span> _: <span class="type">DiskError</span> =&gt; <span class="type">Stop</span> <span class="comment">//如果出现DiskError，就停掉所有的fileWatcher</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Terminated</span>(fileWatcher) =&gt; <span class="comment">//确认这是fileWatcher的Terminated message</span></div><div class="line">        fileWatchers = fileWatchers.filterNot(w =&gt; w == fileWatcher)</div><div class="line">        <span class="keyword">if</span> (fileWatchers.isEmpty) self ! <span class="type">PoisonPill</span> <span class="comment">//所有的fileWatcher都停掉之后，服毒自尽</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>OneForOneStrategy和AllForOneStrategy都提供了maxNrOfRetries和withinTimeRange作为构造参数，分别代表重试几次停止和停止超时时间，按需设置。设置之后，如果重试几次或者超时么有停止，就自动向上传递。下面是一个数据库supervisor的例子：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbImpatientSupervisor</span>(<span class="params">writerProps: <span class="type">Props</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">supervisorStrategy</span> </span>= <span class="type">OneForOneStrategy</span>(</div><div class="line">      maxNrOfRetries = <span class="number">5</span>,</div><div class="line">      withinTimeRange = <span class="number">60</span> seconds) &#123; <span class="comment">//如果5次restart或者60s内没有解决这个问题，就自动上传这个问题给父级supervisor</span></div><div class="line">        <span class="keyword">case</span> _: <span class="type">DbBrokenConnectionException</span> =&gt; <span class="type">Restart</span></div><div class="line">      &#125;</div><div class="line">    <span class="keyword">val</span> writer = context.actorOf(writerProps)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">      <span class="keyword">case</span> m =&gt; writer forward (m)</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><p>容错是Akka相当给力的一部分，也是这个工具对于并发处理的重要组成。’Let it Crash’的哲学并不是主张把所有可能发生的问题都忽略，它也不能处理掉所有的问题。相反，编程人员是希望有恢复措施的，但是怎样使这措施顺利执行是空前的。这一届中我们使用log处理app讲解了容错：</p>
<ul>
<li>监管意味着我们的恢复代码与功能代码的隔离</li>
<li>基于message的Actor模型意味着即便某个actor挂掉，我们还是能继续工作</li>
<li>我们可以忽略、丢弃、重启：自由选择</li>
<li>我们甚至可以将自己处理不了的错误直接抛给父级supervisor</li>
</ul>
<p>有了akka，容错变得很简单。下一章我们要构建几个不同类型的基于actor的app，看一下怎样提供configuration, logging于发布之类的功能。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    

    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/akka/">akka</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/01/akka-in-action-读书笔记（3）/" title="akka in action 读书笔记（3）" itemprop="url">akka in action 读书笔记（3）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-08-01T08:55:55.000Z" itemprop="datePublished"> 发表于 2016-08-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这一篇我们一起看一下:使用akka测试驱动开发。</p>
<p>当TDD刚出现的时候，大家都感觉它浪费很长时间。尤其感觉让测试一些组件的协作更花费时间。Actor提供了一个又去的解决方案：</p>
<ul>
<li>actor可以更直接的测试，因为他们本身就代表具体行为。【几乎所有的TDD都有至少一个BDD（Behavior-Driven-Development）】</li>
<li>普通的单元测试只能测试接口，而且只能分别测试</li>
<li><p>Actor是基于消息的。也就是只要发送message就可以很轻松的模拟各种行为了。</p>
<h4 id="3-1-测试Actor"><a href="#3-1-测试Actor" class="headerlink" title="3.1 测试Actor"></a>3.1 测试Actor</h4><p>  我们使用ScalaTest单元测试框架来测试发送与接收message。<br>  看代码以前，我们要了解，测试Actor相比测试不同的对象还是要稍微复杂一点儿的，原因如下：</p>
<ul>
<li>时间。 发送message是一步的，所以不知道多长时间才能去assert返回值</li>
<li>异步。 Actor是在多个线程中并行运行的。多线程测试相比单线程测试要复杂以下，需要处理一些并发原是变量来同步多个actor的结果，比如lock、latch、barrier等。这些正是我们要远离的。仅仅是一个barrier的错用都会导致一个单元测试block住，从而影响整个test suite。</li>
<li>无状态。actor的内部状态是隐藏的，只能通过ActorRef来访问。单元测试的时候要注意这点。</li>
<li>协作/整合。如果要测试几个actor之间的整合，必须在这些actor之间窃听它们之间传递的message是不是期望值。</li>
</ul>
<hr>
<p>  虽然有以上困难，好在Akka也提供了<code>akka-testkit</code> module。这个module包含了几个可以很方便的进行actor测试的工具。这个module覆盖了下面几种不同的测试类型：</p>
<ul>
<li>单线程测试。 一个actor实例通常并不能直接使用。testkit提供了TestActorRef，它允许访问指定的actor实例。这样就能直接调用actor的方法，来测试我们定义的actor，向测试普通对象一样了。</li>
<li>多线程单元测试。<code>TestKit</code>和<code>TestProbe</code>两个类，让我们方便的接收回复，检查message，为特定message设置到达时限。TestKit有专门的方法来assert期望值。Actor在多线程环境中使用一个普通的dispatcher来运行。</li>
<li><p>多jvm测试。测试远程actor system的时候会用到。</p>
<p>TestActorRef继承了LocalActorRef，设置dispatcher为CallingThreadDispatcher, CallingThreadDispatcher只用来测试。（它直接使用调用者的线程，而不是另起一个线程）。</p>
<p>明眼人看的出来，多线程环境基本贴近于生产环境，所以我们接触最多。<br>关于<a href="http://www.scalatest.org/" target="_blank" rel="external">ScalaTest</a></p>
</li>
</ul>
</li>
</ul>
<h5 id="3-1-1-准备测试"><a href="#3-1-1-准备测试" class="headerlink" title="3.1.1 准备测试"></a>3.1.1 准备测试</h5><p>因为有一些通用的逻辑，我们先定义一个Trait，使测试能够在单元测试结束后自动停止测试系统。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> aia.testdriven</div><div class="line"><span class="comment">//&lt;start id="ch02-stopsystem"/&gt;</span></div><div class="line"><span class="keyword">import</span> org.scalatest.&#123; <span class="type">Suite</span>, <span class="type">BeforeAndAfterAll</span> &#125;</div><div class="line"><span class="keyword">import</span> akka.testkit.<span class="type">TestKit</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">StopSystemAfterAll</span> <span class="keyword">extends</span> <span class="title">BeforeAndAfterAll</span> </span>&#123; </div><div class="line">		<span class="comment">//继承ScalaTest的基础trait</span></div><div class="line">  <span class="keyword">this</span>: <span class="type">TestKit</span> <span class="keyword">with</span> <span class="type">Suite</span> =&gt; <span class="comment">//这个trait只能与使用TestKit的测试使用</span></div><div class="line">  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">afterAll</span></span>() &#123;</div><div class="line">    <span class="keyword">super</span>.afterAll()</div><div class="line">    system.terminate() <span class="comment">//测试完成后关闭测试系统</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们写测试的时候就可以mixin这个trait了。TestKit暴露了一个system变量，可以用来访问测试中创建的actor以及其他信息。</p>
<h4 id="3-2-单向消息"><a href="#3-2-单向消息" class="headerlink" title="3.2 单向消息"></a>3.2 单向消息</h4><p>记住，我们已经不再使用那种触发某个动作，等待response的方式了，所以我们的例子都是使用<code>tell</code>来发送单向消息也就顺理成章了。拜这种fire and forget方式所赐，我们不知道message什么时候到达actor，或者即便到了，我们怎么样进行测试呢？我们期望是发送一个message给一个actor，然后这个actor能够正确的处理这条message。如果actor的处理动作对于外界完全不可见，我们只能保证它处理之后没有出现任何错误，我们应该使用TestActorRef来访问actor的状态，确保它完好。下面是我们需要注意的三种actor：</p>
<ul>
<li>SilentActor。这种actor的行为对于外界不可见，但是中间它会创建一些内部状态。只要处理中没有出现任何错误或异常我们就认为测试通过。检测处理中内部状态的变化就可以了。</li>
<li>SendingActor。这种actor处理完收到的message之后会发送message到其他actor。我们把这种actor当做一个黑盒，查看输入与输出的message就行了。</li>
<li><p>SideEffiectingActor。这种actor接收message，与一个普通对象进行一些交互。发送message给这种actor之后，需要确认以下普通对象是否被按照预期修改了。</p>
<p> 下面我们为以上列举的每种actor都写个test。</p>
</li>
</ul>
<h5 id="3-2-1-SilentActor例子"><a href="#3-2-1-SilentActor例子" class="headerlink" title="3.2.1 SilentActor例子"></a>3.2.1 SilentActor例子</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> aia.testdriven</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.scalatest.&#123;<span class="type">WordSpecLike</span>, <span class="type">MustMatchers</span>&#125;</div><div class="line"><span class="keyword">import</span> akka.testkit.<span class="type">TestKit</span></div><div class="line"><span class="keyword">import</span> akka.actor._</div><div class="line"></div><div class="line"><span class="comment">//This test is ignored in the BookBuild, it's added to the defaultExcludedNames</span></div><div class="line"><span class="comment">//&lt;start id="ch02-silentactor-test01"/&gt;</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SilentActor01Test</span> <span class="keyword">extends</span> <span class="title">TestKit</span>(<span class="params"><span class="type">ActorSystem</span>("testsystem"</span>)) </span></div><div class="line">  <span class="keyword">with</span> <span class="type">WordSpecLike</span> <span class="comment">//WordSpecLike提供了一种易读的DSL来测试BDD形式的测试</span></div><div class="line">  <span class="keyword">with</span> <span class="type">MustMatchers</span> <span class="comment">//MustMatchers提供了易读的assertion</span></div><div class="line">  <span class="keyword">with</span> <span class="type">StopSystemAfterAll</span> &#123; <span class="comment">//我们刚刚定义的，完成测试后关闭system</span></div><div class="line"></div><div class="line">  <span class="string">"A Silent Actor"</span> must &#123; <span class="comment">// 写上文本描述</span></div><div class="line">    <span class="string">"change state when it receives a message, single threaded"</span> in &#123; <span class="comment">// 每个in都描述一个指定的测试</span></div><div class="line">      <span class="comment">//Write the test, first fail</span></div><div class="line">      fail(<span class="string">"not implemented yet"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="string">"change state when it receives a message, multi-threaded"</span> in &#123;</div><div class="line">      <span class="comment">//Write the test, first fail</span></div><div class="line">      fail(<span class="string">"not implemented yet"</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//&lt;end id="ch02-silentactor-test01"/&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//定义一个Actor</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SilentActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">    <span class="keyword">case</span> msg =&gt;  <span class="comment">// 所有接收到的message都被吞如黑洞</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//&lt;end id="ch02-silentactor-test01-imp"/&gt;</span></div></pre></td></tr></table></figure>
<p>以上是一个WordSpec形式的测试，可以写多个文本描述。下面我们定义来一个Actor。</p>
<p>我们首先写测试发送message给这个actor，然后观察它内部状态的变化。</p>
<p>SilentActor和SilentActorProtocol都是为了辅助测试的，后者包含了所有前者支持的message类型，可以方便地对message进行分组管理。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> silentactor02 &#123;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SilentActorTest</span> <span class="keyword">extends</span> <span class="title">TestKit</span>(<span class="params"><span class="type">ActorSystem</span>("testsystem"</span>))</span></div><div class="line">    <span class="keyword">with</span> <span class="type">WordSpecLike</span></div><div class="line">    <span class="keyword">with</span> <span class="type">MustMatchers</span></div><div class="line">    <span class="keyword">with</span> <span class="type">StopSystemAfterAll</span> &#123;</div><div class="line"></div><div class="line">    <span class="string">"A Silent Actor"</span> must &#123;</div><div class="line">      <span class="comment">//&lt;start id="ch02-silentactor-test02"/&gt;</span></div><div class="line">      <span class="string">"change internal state when it receives a message, single"</span> in &#123;</div><div class="line">        <span class="keyword">import</span> <span class="type">SilentActor</span>._ <span class="comment">//引入Protocol定义的message类型</span></div><div class="line"></div><div class="line">        <span class="keyword">val</span> silentActor = <span class="type">TestActorRef</span>[<span class="type">SilentActor</span>] <span class="comment">//为单线程测试创建TestActorRef</span></div><div class="line">        silentActor ! <span class="type">SilentMessage</span>(<span class="string">"whisper"</span>)</div><div class="line">        silentActor.underlyingActor.state must (contain(<span class="string">"whisper"</span>)) <span class="comment">//测试刚刚放进的message在目标actor中</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 对应提到的Protocol</span></div><div class="line">  <span class="class"><span class="keyword">object</span> <span class="title">SilentActor</span> </span>&#123; </div><div class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SilentMessage</span>(<span class="params">data: <span class="type">String</span></span>) <span class="title">//SilentActor可以处理的一种message类型</span></span></div><div class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">GetState</span>(<span class="params">receiver: <span class="type">ActorRef</span></span>)</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SilentActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line">    <span class="keyword">import</span> <span class="type">SilentActor</span>._</div><div class="line">    <span class="keyword">var</span> internalState = <span class="type">Vector</span>[<span class="type">String</span>]()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">SilentMessage</span>(data) =&gt;</div><div class="line">        internalState = internalState :+ data <span class="comment">//state这里是被存储在一个vector中，每个message都会被加入这个vector</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">state</span> </span>= internalState <span class="comment">//放回当前的所有内部状态</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于返回的状态列表是不可变的，测试并不会影响我们验证期望数据。</p>
<p>下面我们看一下多线程版本的。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SilentActorTest</span> <span class="keyword">extends</span> <span class="title">TestKit</span>(<span class="params"><span class="type">ActorSystem</span>("testsystem"</span>))</span></div><div class="line">    <span class="keyword">with</span> <span class="type">WordSpecLike</span></div><div class="line">    <span class="keyword">with</span> <span class="type">MustMatchers</span></div><div class="line">    <span class="keyword">with</span> <span class="type">StopSystemAfterAll</span> &#123;</div><div class="line"></div><div class="line">    <span class="string">"A Silent Actor"</span> must &#123;</div><div class="line">     </div><div class="line">      <span class="string">"change internal state when it receives a message, multi"</span> in &#123;</div><div class="line">        <span class="keyword">import</span> <span class="type">SilentActor</span>._ </div><div class="line"></div><div class="line">        <span class="keyword">val</span> silentActor = system.actorOf(<span class="type">Props</span>[<span class="type">SilentActor</span>], <span class="string">"s3"</span>) <span class="comment">//创建actor的方式不同</span></div><div class="line">        silentActor ! <span class="type">SilentMessage</span>(<span class="string">"whisper1"</span>)</div><div class="line">        silentActor ! <span class="type">SilentMessage</span>(<span class="string">"whisper2"</span>)</div><div class="line">        silentActor ! <span class="type">GetState</span>(testActor) <span class="comment">// 添加了一种消息类型，来返回当前的状态</span></div><div class="line">        expectMsg(<span class="type">Vector</span>(<span class="string">"whisper1"</span>, <span class="string">"whisper2"</span>)) <span class="comment">//测试断言</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">object</span> <span class="title">SilentActor</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SilentMessage</span>(<span class="params">data: <span class="type">String</span></span>)</span></div><div class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">GetState</span>(<span class="params">receiver: <span class="type">ActorRef</span></span>) <span class="title">//添加的消息类型</span></span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SilentActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line">    <span class="keyword">import</span> <span class="type">SilentActor</span>._</div><div class="line">    <span class="keyword">var</span> internalState = <span class="type">Vector</span>[<span class="type">String</span>]()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">SilentMessage</span>(data) =&gt;</div><div class="line">        internalState = internalState :+ data</div><div class="line">      <span class="keyword">case</span> <span class="type">GetState</span>(receiver) =&gt; receiver ! internalState <span class="comment">//返回参数中内部状态给receiver，也就是GetState参数的ActorRef</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>多线程使用TestKit内置的<code>testsystem</code>这个ActorSystem来创建SilentActor。这样我们就不能使用多线程的actor去直接访问actor实例了。这里使用GetState消息封装了一个ActorRef作为参数。TestKit有一个testActor让你用来接收你期望的message。我们在receive里添加的GetState的方法返回了指定actorRef的内部状态。expectMsg方法是期望每个发送到testActor的message都被assert。</p>
<p>这里的internalState依然是不可变的，所以仍然是完全安全的。</p>
<h5 id="3-2-SendingActor例子"><a href="#3-2-SendingActor例子" class="headerlink" title="3.2 SendingActor例子"></a>3.2 SendingActor例子</h5><p>回想以下第一章中的买票的例子，我们需要测试的是党我们买了一个Ticket，那么可以卖的Ticket总数就要减少一个。既然TicketingAgent负责减票并将event继续传递给下一个TicketingAgent，我们只需要创建一个SendingActor，把它作为下一个接收者放到chain里去，然后观察票数变化情况就行了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> aia.testdriven</div><div class="line"></div><div class="line"><span class="keyword">import</span> akka.testkit.<span class="type">TestKit</span></div><div class="line"><span class="keyword">import</span> akka.actor.&#123; <span class="type">Props</span>, <span class="type">ActorRef</span>, <span class="type">Actor</span>, <span class="type">ActorSystem</span> &#125;</div><div class="line"><span class="keyword">import</span> org.scalatest.&#123;<span class="type">WordSpecLike</span>, <span class="type">MustMatchers</span>&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendingActor01Test</span> <span class="keyword">extends</span> <span class="title">TestKit</span>(<span class="params"><span class="type">ActorSystem</span>("testsystem"</span>))</span></div><div class="line">  <span class="keyword">with</span> <span class="type">WordSpecLike</span></div><div class="line">  <span class="keyword">with</span> <span class="type">MustMatchers</span></div><div class="line">  <span class="keyword">with</span> <span class="type">StopSystemAfterAll</span> &#123;</div><div class="line"></div><div class="line">  <span class="string">"A Sending Actor"</span> must &#123;</div><div class="line">    <span class="string">"send a message to an actor when it has finished"</span> in &#123;</div><div class="line">      <span class="keyword">import</span> <span class="type">Kiosk01Protocol</span>._</div><div class="line">      <span class="keyword">val</span> props = <span class="type">Props</span>(<span class="keyword">new</span> <span class="type">Kiosk01</span>(testActor)) <span class="comment">// 下一个TicketingAgent通过构造函数传递，这里我们传的是testActor</span></div><div class="line">      <span class="keyword">val</span> sendingActor = system.actorOf(props, <span class="string">"kiosk1"</span>)</div><div class="line">      <span class="keyword">val</span> tickets = <span class="type">Vector</span>(<span class="type">Ticket</span>(<span class="number">1</span>), <span class="type">Ticket</span>(<span class="number">2</span>), <span class="type">Ticket</span>(<span class="number">3</span>))</div><div class="line">      <span class="keyword">val</span> game = <span class="type">Game</span>(<span class="string">"Lakers vs Bulls"</span>, tickets) <span class="comment">// 湖人对公牛的门票库</span></div><div class="line">      sendingActor ! game</div><div class="line"></div><div class="line">      expectMsgPF() &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Game</span>(_, tickets) =&gt; <span class="comment">//testAcotr应该接收到了一个event</span></div><div class="line">          tickets.size must be(game.tickets.size - <span class="number">1</span>) <span class="comment">// testActor应该接收到了一个ticket被减少了</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Kiosk01Protocol</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>(<span class="params">seat: <span class="type">Int</span></span>) </span></div><div class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span>(<span class="params">name: <span class="type">String</span>, tickets: <span class="type">Seq</span>[<span class="type">Ticket</span>]</span>) <span class="title">//包含message的event</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kiosk01</span>(<span class="params">nextKiosk: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line">  <span class="keyword">import</span> <span class="type">Kiosk01Protocol</span>._</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">    <span class="keyword">case</span> game @ <span class="type">Game</span>(_, tickets) =&gt;</div><div class="line">      nextKiosk ! game.copy(tickets = tickets.tail) <span class="comment">//一个不可变的去掉第一个ticket的副本被发往下一个TicketingAgent</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是一些SendingActor的变种：</p>
<table>
<thead>
<tr>
<th>Actor</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MutatingCopyActor</td>
<td>这种actor创建一个变种的copy，然后发送副本到下一个actor，上面用到的就属于这种</td>
</tr>
<tr>
<td>ForwardingActor</td>
<td>这种actor不修改收到的message，只是转发出去</td>
</tr>
<tr>
<td>TransformingActor</td>
<td>这种actor会根据收到的message创建一个不同类型的message</td>
</tr>
<tr>
<td>SequencingActor</td>
<td>这种actor基于收到的message创建很多的message，然后按序发送出去</td>
</tr>
</tbody>
</table>
<p>前三种使用相同的方式进行测试。</p>
<p>FilteringActor不同于其他的是它会定位我们传递的message是为什么没有通过测试？SequencingActor跟它类似。那么我们怎样确认我们收到了正确数量的message呢？先给FilteringActor写个测试吧。我们要弄一个可以自动过滤重复message的FilteringActor。它有一个已经收到的所有的message的list，每次来新的message的时候都检查是不是已经有了相同的message。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> aia.testdriven</div><div class="line"></div><div class="line"><span class="keyword">import</span> akka.testkit.<span class="type">TestKit</span></div><div class="line"><span class="keyword">import</span> akka.actor.&#123; <span class="type">Actor</span>, <span class="type">Props</span>, <span class="type">ActorRef</span>, <span class="type">ActorSystem</span> &#125;</div><div class="line"><span class="keyword">import</span> org.scalatest.&#123;<span class="type">MustMatchers</span>, <span class="type">WordSpecLike</span> &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilteringActorTest</span> <span class="keyword">extends</span> <span class="title">TestKit</span>(<span class="params"><span class="type">ActorSystem</span>("testsystem"</span>))</span></div><div class="line">  <span class="keyword">with</span> <span class="type">WordSpecLike</span></div><div class="line">  <span class="keyword">with</span> <span class="type">MustMatchers</span></div><div class="line">  <span class="keyword">with</span> <span class="type">StopSystemAfterAll</span> &#123;</div><div class="line">  <span class="string">"A Filtering Actor"</span> must &#123;</div><div class="line">    <span class="string">"filter out particular messages"</span> in &#123;</div><div class="line">      <span class="keyword">import</span> <span class="type">FilteringActor</span>._</div><div class="line">      <span class="keyword">val</span> props = <span class="type">FilteringActor</span>.props(testActor, <span class="number">5</span>)</div><div class="line">      <span class="keyword">val</span> filter = system.actorOf(props, <span class="string">"filter-1"</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">1</span>) <span class="comment">// 发送一串message</span></div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">2</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">1</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">3</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">1</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">4</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">5</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">5</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">6</span>)</div><div class="line">      <span class="keyword">val</span> eventIds = receiveWhile() &#123; <span class="comment">//收集testActor收到的所有满足case语句的message</span></div><div class="line">        <span class="keyword">case</span> <span class="type">Event</span>(id) <span class="keyword">if</span> id &lt;= <span class="number">5</span> =&gt; id</div><div class="line">      &#125;</div><div class="line">      eventIds must be(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="comment">//测试没有收入重复的message</span></div><div class="line">      expectMsg(<span class="type">Event</span>(<span class="number">6</span>))</div><div class="line">    &#125;</div><div class="line">    <span class="string">"filter out particular messages using expectNoMsg"</span> in &#123;</div><div class="line">      <span class="keyword">import</span> <span class="type">FilteringActor</span>._</div><div class="line">      <span class="keyword">val</span> props = <span class="type">FilteringActor</span>.props(testActor, <span class="number">5</span>)</div><div class="line">      <span class="keyword">val</span> filter = system.actorOf(props, <span class="string">"filter-2"</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">1</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">2</span>)</div><div class="line">      expectMsg(<span class="type">Event</span>(<span class="number">1</span>))</div><div class="line">      expectMsg(<span class="type">Event</span>(<span class="number">2</span>))</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">1</span>)</div><div class="line">      expectNoMsg</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">3</span>)</div><div class="line">      expectMsg(<span class="type">Event</span>(<span class="number">3</span>))</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">1</span>)</div><div class="line">      expectNoMsg</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">4</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">5</span>)</div><div class="line">      filter ! <span class="type">Event</span>(<span class="number">5</span>)</div><div class="line">      expectMsg(<span class="type">Event</span>(<span class="number">4</span>))</div><div class="line">      expectMsg(<span class="type">Event</span>(<span class="number">5</span>))</div><div class="line">      expectNoMsg()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">FilteringActor</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>(nextActor: <span class="type">ActorRef</span>, bufferSize: <span class="type">Int</span>) =</div><div class="line">    <span class="type">Props</span>(<span class="keyword">new</span> <span class="type">FilteringActor</span>(nextActor, bufferSize))</div><div class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span>(<span class="params">id: <span class="type">Long</span></span>)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilteringActor</span>(<span class="params">nextActor: <span class="type">ActorRef</span>,</span></span></div><div class="line">                     bufferSize: <span class="type">Int</span>) <span class="keyword">extends</span> <span class="title">Actor</span> &#123;<span class="comment">// 定义buffer大小 </span></div><div class="line">  <span class="keyword">import</span> <span class="type">FilteringActor</span>._</div><div class="line">  <span class="keyword">var</span> lastMessages = <span class="type">Vector</span>[<span class="type">Event</span>]() <span class="comment">//上一批message的vector</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">    <span class="keyword">case</span> msg: <span class="type">Event</span> =&gt;</div><div class="line">      <span class="keyword">if</span> (!lastMessages.contains(msg)) &#123;</div><div class="line">        lastMessages = lastMessages :+ msg</div><div class="line">        nextActor ! msg <span class="comment">// 如果buffer中没有event就发送给下个actor</span></div><div class="line">        <span class="keyword">if</span> (lastMessages.size &gt; bufferSize) &#123;</div><div class="line">          <span class="comment">// 当到了最大buffer，最老的message就被忽略了</span></div><div class="line">          lastMessages = lastMessages.tail <span class="comment">//&lt;co id="ch02-filteringactor-discard"/&gt;</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>receiveWhile方法同样也可以用来测试</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    

    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/akka/">akka</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/21/django的POST或者GET参数映射到对象/" title="django的POST或者GET参数映射到对象" itemprop="url">django的POST或者GET参数映射到对象</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-07-21T11:50:59.000Z" itemprop="datePublished"> 发表于 2016-07-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原理及其简单，就算利用python的自省，有点儿类似java的反射调用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">etl = ETL()</div><div class="line">        dic = dict(request.POST)</div><div class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> dic.iteritems():</div><div class="line">            <span class="keyword">if</span> hasattr(etl, k):</div><div class="line">                setattr(etl, k, v)</div><div class="line">        <span class="keyword">print</span> etl</div></pre></td></tr></table></figure></p>
<p>就这几行代码就可以搞定了。为了公用方便，可以抽出来作为一个module使用。</p>
<p>简单封装了以下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*</span></div><div class="line"><span class="keyword">import</span> logging</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">http的一些常用的工具方法</div><div class="line">'''</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">post2obj</span><span class="params">(obj, post, *excludes)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    将post里的参数对应copy到obj里，主要是方便http接口直接使用obj进行操作</div><div class="line">    :param obj:</div><div class="line">    :param post:</div><div class="line">    :return:</div><div class="line">    '''</div><div class="line">    dic = dict(post)</div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> dic.iteritems():</div><div class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> excludes:</div><div class="line">            <span class="keyword">if</span> hasattr(obj, k):</div><div class="line">                v = <span class="string">''</span>.join(v)</div><div class="line">                setattr(obj, k, v)</div><div class="line">    logging.info(<span class="string">"post params has been copied to  obj -&gt; %s"</span> % obj)</div><div class="line"></div><div class="line">...</div><div class="line">...</div><div class="line">get 同理</div></pre></td></tr></table></figure></p>
<p><code>注意</code>：上面我们使用了’’.join(v)。因为从dict里遍历出来的所有value都是list类型的。而<code>request.POST[&#39;xxx&#39;]</code>取出来的就是正常的unicode类型。list会在后面的处理中出现很多问题，所以这里转成str再使用。</p>
<p>再想想，其实可以通过python的装饰器【对应java里的注释】实现，但是目前不太确定python是否支持java的泛型类的东西，可以用来自动生成操作对象的实例。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    

    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/21/django的奇葩form/" title="django的奇葩form" itemprop="url">django的奇葩form</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-07-21T10:11:22.000Z" itemprop="datePublished"> 发表于 2016-07-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>记录一下遇到的最奇葩的组件：django的form插件。官方文档是：<a href="https://docs.djangoproject.com/ja/1.9/ref/forms/widgets/。" target="_blank" rel="external">https://docs.djangoproject.com/ja/1.9/ref/forms/widgets/。</a></p>
<p>弄这个东西的初衷场景：python里暂时没有找到类似java里类似下面的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"save"</span>,method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON)</div><div class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Object <span class="title">addETL</span><span class="params">(ETL etl)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        etl.setAuthor(<span class="string">"will"</span>);</div><div class="line">        etlService.addETL(etl);</div><div class="line">        <span class="keyword">return</span> <span class="string">"&#123;\"message\" :\"success\"&#125;"</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用这个接口的时候，只需要传递ETL的字段就可以了，不管是POST还是GET方法，都会自己序列化进入ETL对象，然后就可以操作client端传送上来的ETL对象了 。<br>但是在python或者django里本人暂时没有找到这种方便的方式，只能通过request.POST[‘name’]之类的方法，挨个从POST对象里面取出来，再自己用这些属性去初始化ETL对象，之后再去执行save或者等等之类的操作….身为一个优秀的程序员，必须将“懒”的特性发回出来。所以就去django官网找能够实现类似功能的例子，所以就找到了django的form组件。</p>
<p>额外发现是，当我们需要编辑一个已经存在的ETL的时候，可以自动把所有字段渲染到前端。</p>
<p>那么满怀期待地开始了恶心的form探索之旅。</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"etls/add"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></div><div class="line">    &#123;% csrf_token %&#125;</div><div class="line">        &#123;&#123; form.as_p &#125;&#125;</div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>简直是简单的不要不要的。</p>
<p>后端</p>
<h2 id="views文件里定义一个Form。"><a href="#views文件里定义一个Form。" class="headerlink" title="views文件里定义一个Form。"></a>views文件里定义一个Form。</h2><p>自定义一个form<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ETLForm</span><span class="params">(forms.ModelForm)</span>:</span></div><div class="line">    preSql = forms.CharField(widget=forms.Textarea(attrs=&#123;<span class="string">'class'</span>: <span class="string">"form-control"</span>, <span class="string">"size"</span>: <span class="number">10</span>&#125;))</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></div><div class="line">        model = ETL</div><div class="line">        exclude = [<span class="string">'id'</span>, <span class="string">'ctime'</span>]</div></pre></td></tr></table></figure></p>
<p>上面这段，定义了preSql这个字段的显示类型为form的textarea，然后定义来这个textarea的属性，包括class样式。<br>Meta里定义了model的数据模型，还有要去除不显示的字段。也可以指定fields，就是要显示的字段。 怎么方便怎么来就是了。</p>
<p>其实恶心的东西就是这里写的样式了。好，就算能够接受后端把逻辑和样式一起写了。可是对于不是form的样式怎么办呢，有很多页面就不是form啊，比如列表～会有很多样式必须需要在前端写。那样就是前端有样式，后端也有样式，麻蛋，想想头就大。</p>
<p>其实是有种更方便的做法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Form = modelform_factory(Author, form=AuthorForm, localized_fields=(<span class="string">"birth_date"</span>,))</div></pre></td></tr></table></figure></p>
<p>鉴于本人对上面这种后端写样式就已经感觉不能接受了，就没有再继续搞这个东西。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@transaction.atomic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(request, pk)</span>:</span></div><div class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</div><div class="line">        form = ETLForm(request.POST)</div><div class="line">        <span class="keyword">if</span> form.is_valid():</div><div class="line"></div><div class="line"></div><div class="line">            new_etl = form.save()</div><div class="line">            logger.info(<span class="string">'ETL has been created successfully : '</span> + new_etl)</div><div class="line">            <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'metamap:index'</span>))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        etl = ETL.objects.get(pk=pk)</div><div class="line">        form = ETLForm(instance=etl)</div><div class="line">        <span class="keyword">return</span> render(request, <span class="string">'etl/edit.html'</span>, &#123;<span class="string">'form'</span>: form&#125;)</div></pre></td></tr></table></figure>
<p>路由配置是<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url(<span class="string">'etls/(?P&lt;pk&gt;[0-9]+)/$'</span>, etls.edit),</div></pre></td></tr></table></figure></p>
<p><img src="/imgs/django/django-form.png" alt="前端效果图"></p>
<p>记录以下这个奇葩组件，然后使用传统form进行逻辑编写，就算是要到POST里逐个取值，也认了！！！！</p>
<p>widget相关：<a href="https://docs.djangoproject.com/ja/1.9/ref/forms/widgets/" target="_blank" rel="external">https://docs.djangoproject.com/ja/1.9/ref/forms/widgets/</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    

    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/19/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/21/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/youdaonote/" title="youdaonote">youdaonote<sup>187</sup></a></li>
			
		
			
				<li><a href="/tags/源码/" title="源码">源码<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/akka/" title="akka">akka<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/flume/" title="flume">flume<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/ETL/" title="ETL">ETL<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/solr/" title="solr">solr<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/spring/" title="spring">spring<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/调度平台/" title="调度平台">调度平台<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/azkaban/" title="azkaban">azkaban<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/scala/" title="scala">scala<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/ambari/" title="ambari">ambari<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/quartz/" title="quartz">quartz<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/django/" title="django">django<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/架构/" title="架构">架构<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/架构，jaeger/" title="架构，jaeger">架构，jaeger<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ember/" title="ember">ember<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/nodejs/" title="nodejs">nodejs<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/R/" title="R">R<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/guava/" title="guava">guava<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/willcup" target="_blank" title=" 我自己的github">github</a>
            
          </li>
        
          <li>
            
            	<a href="http://thisding.com" target="_blank" title="朋友的主页">Steven&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Will Chen in MeiTuan. <br/>
			元 亨 利 贞.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:chenxin15@meituan.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="Will Chen">Will Chen</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fe6d1f421bbc9962127a50488f9ed37d1' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
