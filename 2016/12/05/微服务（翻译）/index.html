
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <script type="text/javascript">
    (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
    })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
    
    _st('install','yNiKTKaAnwd1uuxVMfiE','2.0.0');
  </script>
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5b99dfd487346155d274c0c49c3fb869";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>

  
    <title>微服务（翻译） | Will&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Will Chen">
    

    
    <meta name="description" content="新架构角度的定义微服务这个名词最近几年比较火，它代表一套独立部署的应用服务的软件设计。然而对于这种架构方式并没有精确的定义，微观组织的业务能力有几个共同的特征：自动化部署、智能终端、语言和数据的分散控制。
微服务是众多软件架构中的一种。以前我们只是轻蔑的瞥一眼，最近几年来微服务的使用效果让我们见证到了它的威力。而且有些学校已经把它当做企业编程系统模式来教学。可悲的是，并没有人明确指出应该怎样构建一">
<meta property="og:type" content="article">
<meta property="og:title" content="微服务（翻译）">
<meta property="og:url" content="https://runningdata.github.io/2016/12/05/微服务（翻译）/index.html">
<meta property="og:site_name" content="Will's Blog">
<meta property="og:description" content="新架构角度的定义微服务这个名词最近几年比较火，它代表一套独立部署的应用服务的软件设计。然而对于这种架构方式并没有精确的定义，微观组织的业务能力有几个共同的特征：自动化部署、智能终端、语言和数据的分散控制。
微服务是众多软件架构中的一种。以前我们只是轻蔑的瞥一眼，最近几年来微服务的使用效果让我们见证到了它的威力。而且有些学校已经把它当做企业编程系统模式来教学。可悲的是，并没有人明确指出应该怎样构建一">
<meta property="og:image" content="http://martinfowler.com/articles/microservices/images/sketch.png">
<meta property="og:image" content="http://martinfowler.com/articles/microservices/images/conways-law.png">
<meta property="og:image" content="http://martinfowler.com/articles/microservices/images/PreferFunctionalStaffOrganization.png">
<meta property="og:image" content="http://martinfowler.com/articles/microservices/images/decentralised-data.png">
<meta property="og:updated_time" content="2017-12-27T13:41:24.797Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="微服务（翻译）">
<meta name="twitter:description" content="新架构角度的定义微服务这个名词最近几年比较火，它代表一套独立部署的应用服务的软件设计。然而对于这种架构方式并没有精确的定义，微观组织的业务能力有几个共同的特征：自动化部署、智能终端、语言和数据的分散控制。
微服务是众多软件架构中的一种。以前我们只是轻蔑的瞥一眼，最近几年来微服务的使用效果让我们见证到了它的威力。而且有些学校已经把它当做企业编程系统模式来教学。可悲的是，并没有人明确指出应该怎样构建一">
<meta name="twitter:image" content="http://martinfowler.com/articles/microservices/images/sketch.png">

    
    <link rel="alternative" href="/atom.xml" title="Will&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Will&#39;s Blog" title="Will&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Will&#39;s Blog">Will&#39;s Blog</a></h1>
				<h2 class="blog-motto">简易 变易 不易</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
                                                <form class="search" action="/search/index.html" method="get" accept-charset="utf-8" target="_blank">
                                                        <label>搜索</label>
                                                <input name="s" type="hidden" value= null ><input type="text" name="q" size="30" placeholder="搜索"><br>
                                                </form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/微服务（翻译）/" title="微服务（翻译）" itemprop="url">微服务（翻译）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T09:12:13.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#新架构角度的定义"><span class="toc-text">新架构角度的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#微服务架构的特点"><span class="toc-text">微服务架构的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#组件化服务"><span class="toc-text">组件化服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#业务管理"><span class="toc-text">业务管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#产品而不是项目"><span class="toc-text">产品而不是项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Smart-endpoints-and-dumb-pipes"><span class="toc-text">Smart endpoints and dumb pipes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Decentralized-Governance-（分权治理-去中心化）"><span class="toc-text">Decentralized Governance （分权治理/去中心化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Decentralized-Data-Management（数据管理去中心化）"><span class="toc-text">Decentralized Data Management（数据管理去中心化）</span></a></li></ol></li></ol></li></ol>
		
		</div>
		
		<h2 id="新架构角度的定义"><a href="#新架构角度的定义" class="headerlink" title="新架构角度的定义"></a>新架构角度的定义</h2><p>微服务这个名词最近几年比较火，它代表一套独立部署的应用服务的软件设计。然而对于这种架构方式并没有精确的定义，微观组织的业务能力有几个共同的特征：自动化部署、智能终端、语言和数据的分散控制。</p>
<p>微服务是众多软件架构中的一种。以前我们只是轻蔑的瞥一眼，最近几年来微服务的使用效果让我们见证到了它的威力。而且有些学校已经把它当做企业编程系统模式来教学。可悲的是，并没有人明确指出应该怎样构建一个微服务架构~</p>
<p>简单来说，微服务就是提供一套服务来开发一个应用，其中每个服务都运行在自己的进程里，它们之间使用轻量级的协议进行沟通，多数是http。这些服务是围绕业务构建的，而且各自独立地被自动化部署。最低限度地集中管理这些服务，因为这些服务可能是各种编程语言写的，也有可能使用各自不同的存储技术。</p>
<p>下面对比整体编程架构来介绍一下微服务架构。一般的应用由三部分构成：前端、数据库、后端服务。后端服务负责处理http请求，执行业务逻辑，接收并更新数据到数据库，选择适当的视图返回给客户端。这样的后端服务就是一个整体编程架构。任何修改都要重新发布整个后端服务。</p>
<p>上面提到的整体架构是构建系统的一个很自然的方式。处理请求的所有的业务逻辑都在一个单一的进程里，你可以使用语言特性讲不通的功能分配给不同的类、函数、命名空间。对于个别关心的东西，你可以在开发人员的笔记本上运行测试。使用一个发布pipeline来保证改变的东西已经被测试过了，然后发布到生产环境。你可以在负载均衡后面运行多个app实例来横向扩展。</p>
<p>整体架构其实比较成功，只是人们慢慢感觉到有些受挫，尤其是越来越多的应用被发布到云中。修改环节紧紧联系在一起，对应用的一小部分进行修改，就需要整体应用都重新构建与发布。随着时间推移，要想保持一个很好的模块化架构变得特别困难。扩展的话也必须扩展整体应用，而不能紧紧扩展指定的一些模块，这样就耗费了很多资源。</p>
<p><img src="http://martinfowler.com/articles/microservices/images/sketch.png" alt="整体架构 与 微服务"></p>
<p>这些困难催生了微服务架构：把app当做服务组来构建。每个服务不但独立部署和扩展，他们还提供严格的模块边界，甚至不同的服务还可以使用不同的编程语言来实现，也可以由不同的团队负责开发与管理。</p>
<p>我们并不是说微服务是创新的，至少它回归到了Unix的设计原则。我们就是认为使用微服务架构思想编程的人还比较少，其实使用它会让我们的软件开发更好。</p>
<h2 id="微服务架构的特点"><a href="#微服务架构的特点" class="headerlink" title="微服务架构的特点"></a>微服务架构的特点</h2><p> While we authors have been active members of this rather loose community, our intention is to attempt a description of what we see in our own work and in similar efforts by teams we know of. In particular we are not laying down some definition to conform to.</p>
<p>我们并不能对微服务下一个官方定义，但是我们可以尝试描述一下微服务的几个共同特点。并不是所有的微服务架构都有这些特点，但是我们希望多数的微服务都展示出了这些特点的大部分。</p>
<h4 id="组件化服务"><a href="#组件化服务" class="headerlink" title="组件化服务"></a>组件化服务</h4><p>软件工业中我们一般把系统设计成可以将component组装起来的架构，多数是使用公用的libraries实现。</p>
<p>提到component，我们看一下它的定义，component是软件的一个单元，独立、可替换、可升级。</p>
<p>Microservice architectures will use libraries, but their primary way of componentizing their own software is by breaking down into services. We define libraries as components that are linked into a program and called using in-memory function calls, while services are out-of-process components who communicate with a mechanism such as a web service request, or remote procedure call. (This is a different concept to that of a service object in many OO programs [3].)</p>
<p>微服务架构把软件打散成不同的服务，也是用libraries。libraries是被链接到程序中，在内存中调用函数的component，而服务是进程之外的component，使用类似web service request进行沟通，或者RPC。</p>
<p>One main reason for using services as components (rather than libraries) is that services are independently deployable. If you have an application [4] that consists of a multiple libraries in a single process, a change to any single component results in having to redeploy the entire application. But if that application is decomposed into multiple services, you can expect many single service changes to only require that service to be redeployed. That’s not an absolute, some changes will change service interfaces resulting in some coordination, but the aim of a good microservice architecture is to minimize these through cohesive service boundaries and evolution mechanisms in the service contracts.</p>
<p>把服务组件化的一个主要理由就是服务可以独立部署。如果你有一个单进程中包含多个libraries的应用，修改任何一个component都需要重新部署整个应用。但是如果你的应用解耦成为多个服务，你可以只重新部署修改到的地方。当然这并不是绝对的，如果修改了服务接口，肯定也要重新修改部署协作的服务，但是微服务的目标就是通过黏着的服务边界和服务规范的进化机制最小化这个修改范围。</p>
<p>Another consequence of using services as components is a more explicit component interface. Most languages do not have a good mechanism for defining an explicit Published Interface. Often it’s only documentation and discipline that prevents clients breaking a component’s encapsulation, leading to overly-tight coupling between components. Services make it easier to avoid this by using explicit remote call mechanisms.</p>
<p>另一个服务组件化的结果就是更灵活的component接口。大多数语言都不能定义一个明确详实的公共接口。通常只能通过文档和规范来约束客户端遵循component的封装，导致组件之间过度依赖。组件化服务可以使用明确的远程调用机制避免这些。</p>
<p>Using services like this does have downsides. Remote calls are more expensive than in-process calls, and thus remote APIs need to be coarser-grained, which is often more awkward to use. If you need to change the allocation of responsibilities between components, such movements of behavior are harder to do when you’re crossing process boundaries.</p>
<p>使用这样的服务也是有缺点的。远程多用通常比进程内调用代价昂贵，因此远程API需要是粗粒度的。如果你必须修改component之间的职责分配，这样的行为移动非常难弄，尤其是跨进程边界的时候。</p>
<p>At a first approximation, we can observe that services map to runtime processes, but that is only a first approximation. A service may consist of multiple processes that will always be developed and deployed together, such as an application process and a database that’s only used by that service.</p>
<p>第一印象，我们可以把这样的服务看做是运行时进程。注意，这只是为了好理解一些，事实上一个service可以包含多个进程，比如一个应用进程和这个进程使用的数据库进程。</p>
<h4 id="业务管理"><a href="#业务管理" class="headerlink" title="业务管理"></a>业务管理</h4><p>When looking to split a large application into parts, often management focuses on the technology layer, leading to UI teams, server-side logic teams, and database teams. When teams are separated along these lines, even simple changes can lead to a cross-team project taking time and budgetary approval. A smart team will optimise around this and plump for the lesser of two evils - just force the logic into whichever application they have access to. Logic everywhere in other words. This is an example of Conway’s Law[5] in action.</p>
<p>当把一个大的应用切分成多个部分的时候，通常管理就集中在技术层面，出现UI团队，后端逻辑团队，数据库团队。当各个团队分成这些战线之后，即便是特别小的改变也是一个跨团队项目，需要时间和预算。一个牛逼的团队会优化这些东西，取这两个恶魔中比较少的那个。强制把业务逻辑放到一个必须存在的地方。换句话说导出都写逻辑。这是Conway’s Law in action的一个实例。</p>
<blockquote>
<p>Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure.<br>– Melvyn Conway, 1967</p>
<p>任何组织的系统都是组织结构沟通结构的复制。</p>
</blockquote>
<p><img src="http://martinfowler.com/articles/microservices/images/conways-law.png" alt="Conway&#39;s Law in action"></p>
<p>The microservice approach to division is different, splitting up into services organized around business capability. Such services take a broad-stack implementation of software for that business area, including user-interface, persistant storage, and any external collaborations. Consequently the teams are cross-functional, including the full range of skills required for the development: user-experience, database, and project management.</p>
<p>微服务的切分不同，它是围绕业务切分服务。这样的服务包含特定业务领域系统的所有技术栈的实现，包含UI、持久存储、外部协作。结果这样的团队就跨功能，包含开发所需的所有的技术：UI、数据库、项目管理。</p>
<p><img src="http://martinfowler.com/articles/microservices/images/PreferFunctionalStaffOrganization.png" alt="Service boundaries reinforced by team boundaries"></p>
<p>One company organised in this way is www.comparethemarket.com. Cross functional teams are responsible for building and operating each product and each product is split out into a number of individual services communicating via a message bus.</p>
<p>www.comparethemarket.com就是这样组织的一个公司。跨功能团队负责构建和操作每个产品，每个产品也都被切分成几个单独的服务，这些服务之间通过message bus沟通。</p>
<p>Large monolithic applications can always be modularized around business capabilities too, although that’s not the common case. Certainly we would urge a large team building a monolithic application to divide itself along business lines. The main issue we have seen here, is that they tend to be organised around too many contexts. If the monolith spans many of these modular boundaries it can be difficult for individual members of a team to fit them into their short-term memory. Additionally we see that the modular lines require a great deal of discipline to enforce. The necessarily more explicit separation required by service components makes it easier to keep the team boundaries clear.</p>
<p>大的整体应用通常也可以围绕业务进行模块化，尽管还不是通用案例。当然我们需要推动一个大的团队构建一个整体应用根据业务线进行切割。我们在这里遇到的主要的问题是，需要这里面的组织会包含太多的context。如果这个整体应用贯穿了所有模块边界，那么就很难让团队里的个人成员把他们短期记忆住。另外我们知道模块线需要一个准则。 服务组价需要一定更明确的分离，这样能够让团队边界也更清晰。</p>
<h4 id="产品而不是项目"><a href="#产品而不是项目" class="headerlink" title="产品而不是项目"></a>产品而不是项目</h4><p>Most application development efforts that we see use a project model: where the aim is to deliver some piece of software which is then considered to be completed. On completion the software is handed over to a maintenance organization and the project team that built it is disbanded.</p>
<p>我们见的多数的应用开发都是使用项目模型：目标就是交付软件的某些片段。完成后，软件就转交给运维，然后项目团队就解散了。</p>
<p>Microservice proponents tend to avoid this model, preferring instead the notion that a team should own a product over its full lifetime. A common inspiration for this is Amazon’s notion of “you build, you run it” where a development team takes full responsibility for the software in production. This brings developers into day-to-day contact with how their software behaves in production and increases contact with their users, as they have to take on at least some of the support burden.</p>
<p>微服务支持者要避免这种情况，一个团队应该负责产品的整个生命周期。亚马逊的口号：谁构建，谁运行。一个开发团队对于生产线上的软件要全权负责。这样开发者每天都会考虑他的软件在生成环境运行的情况咋样，也多跟他的用户沟通，他们必须多少承担一些事情。</p>
<p>The product mentality, ties in with the linkage to business capabilities. Rather than looking at the software as a set of functionality to be completed, there is an on-going relationship where the question is how can software assist its users to enhance the business capability.</p>
<p>产品是与业务线贴合的。除了把软件当做一组完成的功能，还有一个持续的关系，就是软件怎样辅助它的用户来加强业务能力。</p>
<h4 id="Smart-endpoints-and-dumb-pipes"><a href="#Smart-endpoints-and-dumb-pipes" class="headerlink" title="Smart endpoints and dumb pipes"></a>Smart endpoints and dumb pipes</h4><p>When building communication structures between different processes, we’ve seen many products and approaches that stress putting significant smarts into the communication mechanism itself. A good example of this is the Enterprise Service Bus (ESB), where ESB products often include sophisticated facilities for message routing, choreography, transformation, and applying business rules.</p>
<p>当为不同的进程构建沟通结构的时候，我们见过很多产品都强调吧关键的smart放进沟通机制本身中。一个例子就是ESB。ESB产品通常都包含复杂的设备来支持消息路由、编排、转化、应用业务规则。</p>
<p>The microservice community favours an alternative approach: smart endpoints and dumb pipes. Applications built from microservices aim to be as decoupled and as cohesive as possible - they own their own domain logic and act more as filters in the classical Unix sense - receiving a request, applying logic as appropriate and producing a response. These are choreographed using simple RESTish protocols rather than complex protocols such as WS-Choreography or BPEL or orchestration by a central tool.</p>
<p>微服务组织最喜欢另一种方式：smart endpoints and dumb pipes. 使用微服务构建的应用旨在尽可能解耦，边界尽可能清洗-他们都有自己的逻辑，表现的像个经典Unix派感觉的filter - 接收一个请求，应用业务逻辑，然后产生一个response。他们被使用简单的REST系列协议编排，而不是类似WS-Choreography或者BPRL啥的复杂的协议。</p>
<p>The two protocols used most commonly are HTTP request-response with resource API’s and lightweight messaging[6]. The best expression of the first is</p>
<p>两个最常用的协议是带有resource API的HTTP request-reponse，还有轻量级消息协议。前者最好的表达是：</p>
<blockquote>
<p>Be of the web, not behind the web<br>– Ian Robinson</p>
</blockquote>
<p>Microservice teams use the principles and protocols that the world wide web (and to a large extent, Unix) is built on. Often used resources can be cached with very little effort on the part of developers or operations folk.</p>
<p>不会翻译。</p>
<p>The second approach in common use is messaging over a lightweight message bus. The infrastructure chosen is typically dumb (dumb as in acts as a message router only) - simple implementations such as RabbitMQ or ZeroMQ don’t do much more than provide a reliable asynchronous fabric - the smarts still live in the end points that are producing and consuming messages; in the services.</p>
<p>后者通常通过一个轻量级的message bug来使用。基础设施通常选用dumb，简单的实现例如RabbitMQ、ZeroMQ，并没有为一个可靠的异步fabric多做了些什么 - smart还是在生成和消费message的终端上。</p>
<p>In a monolith, the components are executing in-process and communication between them is via either method invocation or function call. The biggest issue in changing a monolith into microservices lies in changing the communication pattern. A naive conversion from in-memory method calls to RPC leads to chatty communications which don’t perform well. Instead you need to replace the fine-grained communication with a coarser -grained approach.</p>
<p>在一个整体应用中，component是运行在同一个进程内的，可以通过方法触发或函数调用来相互沟通。切分成为微服务后，一个比较大的问题就是沟通模型。从内存中的方法调用到RPC导致了啰嗦的沟通机制。除此之外，你必须使用细粒度沟通替换为粗粒度的。</p>
<h4 id="Decentralized-Governance-（分权治理-去中心化）"><a href="#Decentralized-Governance-（分权治理-去中心化）" class="headerlink" title="Decentralized Governance （分权治理/去中心化）"></a>Decentralized Governance （分权治理/去中心化）</h4><p>One of the consequences of centralised governance is the tendency to standardise on single technology platforms. Experience shows that this approach is constricting - not every problem is a nail and not every solution a hammer. We prefer using the right tool for the job and while monolithic applications can take advantage of different languages to a certain extent, it isn’t that common.</p>
<p>中心化治理的结果是标准趋向于单一技术平台。经验表明这种方式是不太好的，通常不是一个方案就能解决掉所有问题。我们更愿意使用合适的工具来做对应的工作，整体应用可以利用不同语言解决某个特定的范围，但是这并不常见。</p>
<p>Splitting the monolith’s components out into services we have a choice when building each of them. You want to use Node.js to standup a simple reports page? Go for it. C++ for a particularly gnarly near-real-time component? Fine. You want to swap in a different flavour of database that better suits the read behaviour of one component? We have the technology to rebuild him.</p>
<p>把整体应用切分成组件化服务的话，我们可以选择啥时候构建每个组件。想用nodejs创建一个简单的表单页？做呗。想用c++弄一个实时处理组件？好啊。你想在不同的数据库支持之间切换，来适应个别组件的读取？我们可以重新构建它。</p>
<p>Of course, just because you can do something, doesn’t mean you should - but partitioning your system in this way means you have the option.</p>
<p>当然，并不是你可以做，你就应该做。只是把你当系统以这种方式拆分后，你可以选择做或者不做。</p>
<p>Teams building microservices prefer a different approach to standards too. Rather than use a set of defined standards written down somewhere on paper they prefer the idea of producing useful tools that other developers can use to solve similar problems to the ones they are facing. These tools are usually harvested from implementations and shared with a wider group, sometimes, but not exclusively using an internal open source model. Now that git and github have become the de facto version control system of choice, open source practices are becoming more and more common in-house .</p>
<p>各个团队构建微服务的方式也不尽相同。他们会设计对生产有用的工具，供其他开发者重用，解决类似的问题，而不是使用一系列定义好的标准写在纸上。这些工具通常从一些实现或者在一个共享组里获得的。现在git和github都成为了版本控制系统，开源的练习也越来越多见。</p>
<p>Netflix is a good example of an organisation that follows this philosophy. Sharing useful and, above all, battle-tested code as libraries encourages other developers to solve similar problems in similar ways yet leaves the door open to picking a different approach if required. Shared libraries tend to be focused on common problems of data storage, inter-process communication and as we discuss further below, infrastructure automation.</p>
<p>netflix是追随这个哲学的代表组织。分享有用的精炼的代码，作为libraries提供给其他的开发者使用，解决类似的问题。共享的libraries会慢慢在数据存储、进程内沟通、基础设置自动化问题上被注意到。</p>
<p>For the microservice community, overheads are particularly unattractive. That isn’t to say that the community doesn’t value service contracts. Quite the opposite, since there tend to be many more of them. It’s just that they are looking at different ways of managing those contracts. Patterns like Tolerant Reader and Consumer-Driven Contracts are often applied to microservices. These aid service contracts in evolving independently. Executing consumer driven contracts as part of your build increases confidence and provides fast feedback on whether your services are functioning. Indeed we know of a team in Australia who drive the build of new services with consumer driven contracts. They use simple tools that allow them to define the contract for a service. This becomes part of the automated build before code for the new service is even written. The service is then built out only to the point where it satisfies the contract - an elegant approach to avoid the ‘YAGNI’[9] dilemma when building new software. These techniques and the tooling growing up around them, limit the need for central contract management by decreasing the temporal coupling between services.</p>
<p>对于微服务社区，一般费用是不太惹人注意的。不是说社区不重视服务规范。正相反，很重视服务规范。只是在各种方式来管理这些规范。诸如 Tolerant Reader和Consumer-Driven的规范模型经常被应用于微服务。这帮助服务规范独立展开。</p>
<p>Perhaps the apogee of decentralised governance is the build it / run it ethos popularised by Amazon. Teams are responsible for all aspects of the software they build including operating the software 24/7. Devolution of this level of responsibility is definitely not the norm but we do see more and more companies pushing responsibility to the development teams. Netflix is another organisation that has adopted this ethos[11]. Being woken up at 3am every night by your pager is certainly a powerful incentive to focus on quality when writing your code. These ideas are about as far away from the traditional centralized governance model as it is possible to be.</p>
<p>获取去中心化治理的至高点是Amazon号召的构建/运行。各种团队也24/7的负责了软件的不同方面。责任的转义肯定不是规范，但是我们看到了越来越多的公司把责任推给了开发团队。netflix是融合了这种号召的另一类组织。你的手机每天教你半夜3点起来肯定一个很牛逼的动力，让你专注于写代码的质量。</p>
<h4 id="Decentralized-Data-Management（数据管理去中心化）"><a href="#Decentralized-Data-Management（数据管理去中心化）" class="headerlink" title="Decentralized Data Management（数据管理去中心化）"></a>Decentralized Data Management（数据管理去中心化）</h4><p>Decentralization of data management presents in a number of different ways. At the most abstract level, it means that the conceptual model of the world will differ between systems. This is a common issue when integrating across a large enterprise, the sales view of a customer will differ from the support view. Some things that are called customers in the sales view may not appear at all in the support view. Those that do may have different attributes and (worse) common attributes with subtly different semantics.</p>
<p>数据管理的去中心化代表着几种不同的方式。最抽象的层次上讲，它表示概念模型在系统之间是不同的。在整个大公司的系统的时候这个问题很常见，销售视图不同于支持视图。有一些customer在销售视图里，而在支持视图没有。还有有不同的属性和相同的属性，但是有不同的语义。</p>
<p>This issue is common between applications, but can also occur within applications, particular when that application is divided into separate components. A useful way of thinking about this is the Domain-Driven Design notion of Bounded Context. DDD divides a complex domain up into multiple bounded contexts and maps out the relationships between them. This process is useful for both monolithic and microservice architectures, but there is a natural correlation between service and context boundaries that helps clarify, and as we describe in the section on business capabilities, reinforce the separations.</p>
<p>这个问题在应用之间是很常见的，在app内部也会发生，尤其是应用拆分成多个component之后。考虑这个一个很好的方式是把它看做bounded contexts的Domain-Driven设计概念。DDD气氛一个复杂的domain到多个bounded contexts，然后映射这些关系。这个过程对整体应用和微服务架构都有用，但是在service和context边界之间有一层自然的关联，这层关联帮助清晰化、加强了分离界限。</p>
<p>As well as decentralizing decisions about conceptual models, microservices also decentralize data storage decisions. While monolithic applications prefer a single logical database for persistant data, enterprises often prefer a single database across a range of applications - many of these decisions driven through vendor’s commercial models around licensing. Microservices prefer letting each service manage its own database, either different instances of the same database technology, or entirely different database systems - an approach called Polyglot Persistence. You can use polyglot persistence in a monolith, but it appears more frequently with microservices.</p>
<p>像概念模型的去中心化一样，微服务也对数据存储方案去中心化。整体应用通常是一个逻辑数据库来持久化数据，企业通常使用一个单独的数据库给多个应用。微服务更原因让每个服务管理自己的数据库，甚至整个数据库系统-Polyglot Persistence。你可以在整体应用中使用Polyglot Persistence，但是它更常见与微服务架构中。</p>
<p><img src="http://martinfowler.com/articles/microservices/images/decentralised-data.png" alt=""></p>
<p>参考：<a href="http://martinfowler.com/articles/microservices.html" target="_blank" rel="external">http://martinfowler.com/articles/microservices.html</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/youdaonote/">youdaonote</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://runningdata.github.io/2016/12/05/微服务（翻译）/" data-title="微服务（翻译） | Will&#39;s Blog" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/12/09/一致性协议zab与raft/" title="一致性协议zab与raft">
  <strong>上一篇：</strong><br/>
  <span>
  一致性协议zab与raft</span>
</a>
</div>


<div class="next">
<a href="/2016/12/05/ambari故障记录/"  title="ambari故障记录">
 <strong>下一篇：</strong><br/> 
 <span>ambari故障记录
</span>
</a>
</div>

</nav>

	
<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2016/12/05/微服务（翻译）/" data-title="微服务（翻译）" data-url="https://runningdata.github.io/2016/12/05/微服务（翻译）/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"ruoyuchen"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#新架构角度的定义"><span class="toc-number">1.</span> <span class="toc-text">新架构角度的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#微服务架构的特点"><span class="toc-number">2.</span> <span class="toc-text">微服务架构的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#组件化服务"><span class="toc-number">2.0.1.</span> <span class="toc-text">组件化服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#业务管理"><span class="toc-number">2.0.2.</span> <span class="toc-text">业务管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#产品而不是项目"><span class="toc-number">2.0.3.</span> <span class="toc-text">产品而不是项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Smart-endpoints-and-dumb-pipes"><span class="toc-number">2.0.4.</span> <span class="toc-text">Smart endpoints and dumb pipes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Decentralized-Governance-（分权治理-去中心化）"><span class="toc-number">2.0.5.</span> <span class="toc-text">Decentralized Governance （分权治理/去中心化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Decentralized-Data-Management（数据管理去中心化）"><span class="toc-number">2.0.6.</span> <span class="toc-text">Decentralized Data Management（数据管理去中心化）</span></a></li></ol></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/youdaonote/" title="youdaonote">youdaonote<sup>187</sup></a></li>
			
		
			
				<li><a href="/tags/源码/" title="源码">源码<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/akka/" title="akka">akka<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/flume/" title="flume">flume<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/ETL/" title="ETL">ETL<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/solr/" title="solr">solr<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/spring/" title="spring">spring<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/调度平台/" title="调度平台">调度平台<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/azkaban/" title="azkaban">azkaban<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/scala/" title="scala">scala<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/ambari/" title="ambari">ambari<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/quartz/" title="quartz">quartz<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/nodejs/" title="nodejs">nodejs<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Solr/" title="Solr">Solr<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/guava/" title="guava">guava<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/heroku/" title="heroku">heroku<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/hdfs/" title="hdfs">hdfs<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/hue/" title="hue">hue<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ElasticSearch/" title="ElasticSearch">ElasticSearch<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/willcup" target="_blank" title=" 我自己的github">github</a>
            
          </li>
        
          <li>
            
            	<a href="http://thisding.com" target="_blank" title="朋友的主页">Steven&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Will Chen in MeiTuan. <br/>
			元 亨 利 贞.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:chenxin15@meituan.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Will Chen">Will Chen</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fe6d1f421bbc9962127a50488f9ed37d1' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
