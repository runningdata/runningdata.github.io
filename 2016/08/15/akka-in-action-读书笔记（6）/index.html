
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <script type="text/javascript">
    (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
    })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
    
    _st('install','yNiKTKaAnwd1uuxVMfiE','2.0.0');
  </script>
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5b99dfd487346155d274c0c49c3fb869";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>

  
    <title>akka in action 读书笔记（6） | Will&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Will Chen">
    

    
    <meta name="description" content="这一章我们介绍：

scale out
分布式的卖票app
远程使用
测试分布式的actor系统

这一章中，我们会拿出第二章的例子来进行scale out，也就是在更多的机器上部署同一个app。【回忆一下scale up，在更多的jvm上部署同一个app】
这一章只介绍scale out，下一章介绍集群使用。13章会深入scale out的一些细节。
6.1 scale out不要指望一下子就能">
<meta property="og:type" content="article">
<meta property="og:title" content="akka in action 读书笔记（6）">
<meta property="og:url" content="https://runningdata.github.io/2016/08/15/akka-in-action-读书笔记（6）/index.html">
<meta property="og:site_name" content="Will's Blog">
<meta property="og:description" content="这一章我们介绍：

scale out
分布式的卖票app
远程使用
测试分布式的actor系统

这一章中，我们会拿出第二章的例子来进行scale out，也就是在更多的机器上部署同一个app。【回忆一下scale up，在更多的jvm上部署同一个app】
这一章只介绍scale out，下一章介绍集群使用。13章会深入scale out的一些细节。
6.1 scale out不要指望一下子就能">
<meta property="og:image" content="https://runningdata.github.io/imgs/akka/akka_6_common_network_topo.png">
<meta property="og:image" content="https://runningdata.github.io/imgs/akka/akka_6_sigle_to_cli_serv.png">
<meta property="og:image" content="https://runningdata.github.io/imgs/akka/akka_6_remote_actor_path.png">
<meta property="og:image" content="https://runningdata.github.io/imgs/akka/akka_6_remotelooup_boxoffice_actor.png">
<meta property="og:image" content="https://runningdata.github.io/imgs/akka/akka_6_remotelooup_actor.png">
<meta property="og:image" content="https://runningdata.github.io/imgs/akka/akka_6_multi_jvm_test_flow.png">
<meta property="og:updated_time" content="2017-12-27T13:39:20.401Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="akka in action 读书笔记（6）">
<meta name="twitter:description" content="这一章我们介绍：

scale out
分布式的卖票app
远程使用
测试分布式的actor系统

这一章中，我们会拿出第二章的例子来进行scale out，也就是在更多的机器上部署同一个app。【回忆一下scale up，在更多的jvm上部署同一个app】
这一章只介绍scale out，下一章介绍集群使用。13章会深入scale out的一些细节。
6.1 scale out不要指望一下子就能">
<meta name="twitter:image" content="https://runningdata.github.io/imgs/akka/akka_6_common_network_topo.png">

    
    <link rel="alternative" href="/atom.xml" title="Will&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Will&#39;s Blog" title="Will&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Will&#39;s Blog">Will&#39;s Blog</a></h1>
				<h2 class="blog-motto">简易 变易 不易</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
                                                <form class="search" action="/search/index.html" method="get" accept-charset="utf-8" target="_blank">
                                                        <label>搜索</label>
                                                <input name="s" type="hidden" value= null ><input type="text" name="q" size="30" placeholder="搜索"><br>
                                                </form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/15/akka-in-action-读书笔记（6）/" title="akka in action 读书笔记（6）" itemprop="url">akka in action 读书笔记（6）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Will Chen" target="_blank" itemprop="author">Will Chen</a>
		
  <p class="article-time">
    <time datetime="2016-08-15T10:51:25.000Z" itemprop="datePublished"> 发表于 2016-08-15</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-scale-out"><span class="toc-text">6.1 scale out</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-通用网络拓扑"><span class="toc-text">6.1.1 通用网络拓扑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-为何要分布式编程模型"><span class="toc-text">6.1.2 为何要分布式编程模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-scale-out-with-remoting"><span class="toc-text">6.2 scale out with remoting</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-动手写程序"><span class="toc-text">6.2.1 动手写程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-远程REPL"><span class="toc-text">6.2.2 远程REPL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-远程查找"><span class="toc-text">6.2.3 远程查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-远程发布"><span class="toc-text">6.2.4 远程发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-5-Multi-JVM-testing"><span class="toc-text">6.2.5 Multi-JVM testing</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-总结"><span class="toc-text">6.3 总结</span></a></li></ol>
		
		</div>
		
		<p>这一章我们介绍：</p>
<ul>
<li>scale out</li>
<li>分布式的卖票app</li>
<li>远程使用</li>
<li>测试分布式的actor系统</li>
</ul>
<p>这一章中，我们会拿出第二章的例子来进行scale out，也就是在更多的机器上部署同一个app。【回忆一下scale up，在更多的jvm上部署同一个app】</p>
<p>这一章只介绍scale out，下一章介绍集群使用。13章会深入scale out的一些细节。</p>
<h2 id="6-1-scale-out"><a href="#6-1-scale-out" class="headerlink" title="6.1 scale out"></a>6.1 scale out</h2><p>不要指望一下子就能够把任何app扩展到几千台机器，分布式计算是众所周知的难点。akka只是让分布式计算简单一些，让并发编程简单一些，我们这里还是使用 GoTicks.com 项目，把它弄成分布式的。</p>
<p>许多网络技术都使用RPC，这种方式尽量掩饰本地调用与远程调用的不同，主要思想是既然本地调用很简单，那么就让编程人员像调用本地方法一样调用远程方法。这种通信方式对于点对点的server连接是有效的，但是对于大型网络并不是一个好的方案。面向message的中间件可以解决这个问题，但使app理解吸收message系统到app层的代价有些大。akka另辟蹊径，远程协作者相对透明，不用修改akka代码。</p>
<p>进入探讨之前，先看一下网络拓扑的例子和一些通用术语。要是你对这些已经很了解了就直接跳到6.2.</p>
<h4 id="6-1-1-通用网络拓扑"><a href="#6-1-1-通用网络拓扑" class="headerlink" title="6.1.1 通用网络拓扑"></a>6.1.1 通用网络拓扑</h4><p><img src="/imgs/akka/akka_6_common_network_topo.png" alt="通用网络拓扑"></p>
<ul>
<li>Node: 在网络中运行着的一个app，是网络拓扑的一个连接点。一个server上可以有多个node。</li>
<li>Role： 每个node在分布式系统中都有自己指定的Role。它代表着这个node可以执行一些列的特定任务。</li>
<li>transport protocol ： node使用指定的传输协议来互相沟通，比如TCP/IP</li>
<li>membership：当许多node在同一个分布式系统中的时候，他们公用一个group membership。这个membership可以是静态或动态的。静态是指node的数量和角色都是固定不变的。动态的是允许node自由加入或离开网络，也可能在不同时刻担任不同的角色。静态的最简单，也最脆弱。动态的则可以随着node的增多动态调整node之间的关系，可以应对一些错误问题。当有node加入或者离开网络的时候，需要有一种discovery机制。</li>
</ul>
<h4 id="6-1-2-为何要分布式编程模型"><a href="#6-1-2-为何要分布式编程模型" class="headerlink" title="6.1.2 为何要分布式编程模型"></a>6.1.2 为何要分布式编程模型</h4><p>扩展多n多node的第一步是县弄出一个本地的app支持分布逻辑？我们可以只定义抽象的处理逻辑，然某个牛叉的工具去处理这些转化细节么？答案是no。只指出分布式和本地环境的区别是不够的。根据论文 A Note on Distributed Computing所说，在本地编程和分布式编程，有4个重要的区别：延迟、内存访问、部分失败、并发。下面是一个简单的总结：</p>
<ul>
<li>延迟：在协作者之间出现网络意味着每个message都需要更长的时间，可能由于各种网络原因造成延迟</li>
<li>部分失败：当系统的部分功能并不总是可见、有时消失有时又出现，我们很难确定整个系统都能正常工作。</li>
<li>内存访问： 在本地系统中获取一个内存对象的引用基本不会失败，但是对于分布式系统就失败概率就变大了。</li>
<li>并发： no one ‘owner’ of everything</li>
</ul>
<p>由于以上因素，我们不能在分布式环境中使用本地编程模型。akka的切入点恰恰相反，只需要一个分布式编程模型，同时适用于本地系统和分布式系统。前面提到的论文也提到这个观点，但是有些关心会不会把编程难度提高到分布式编程的水平。</p>
<p>时代变了。前面章节我们介绍到了并发编程的易用性。我们已经熟用了异步迭代，部分失败处理，并发之间不共享任何状态，简化了多核编程，我们已经准备好弄一个分布式环境了。</p>
<h2 id="6-2-scale-out-with-remoting"><a href="#6-2-scale-out-with-remoting" class="headerlink" title="6.2 scale out with remoting"></a>6.2 scale out with remoting</h2><p>我们先选区一个最简单的网络拓扑模型：使用两个node组成client-server 静态网络拓扑。两个node一个是前端，一个是后端。REST接口运行在前端node上，BoxOffice和所有的TicketSeller运行在后端node上。node之间互相有一个静态的网络地址引用。如下图：<br><img src="/imgs/akka/akka_6_sigle_to_cli_serv.png" alt="从单个节点到client-&gt;server的变化"></p>
<p>我们需要使用到akka-remote module。</p>
<p>在本地模式中，当有新的Event的时候，BoxOffice Actor就创建TicketSeller actor。在client-server拓扑中也是这样。只是我们可以看到使用akka-remote之后就可以远程创建与发布actor了。前端使用它知道的地址在后端找负责创建TicketSeller的BoxOffice actor。注意还有一个变化就是前端在后端远程部署了一个BoxOffice actor。</p>
<h4 id="6-2-1-动手写程序"><a href="#6-2-1-动手写程序" class="headerlink" title="6.2.1 动手写程序"></a>6.2.1 动手写程序</h4><p>在源码的chapter6文件夹里有一个对chapter2的升级版。</p>
<p>首先我们修改以下sbt文件，添加akka-remote和akka-mutlnode-testkit依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;com.typesafe.akka&quot;       %%  &quot;akka-remote&quot;                    % akkaVersion,</div><div class="line">&quot;com.typesafe.akka&quot;       %%  &quot;akka-multi-node-testkit&quot;        % akkaVersion   % &quot;test&quot;,</div></pre></td></tr></table></figure></p>
<p>调用sbt update来pull这些依赖。</p>
<h4 id="6-2-2-远程REPL"><a href="#6-2-2-远程REPL" class="headerlink" title="6.2.2 远程REPL"></a>6.2.2 远程REPL</h4><p>akka提供两种方式来获取远程node上的actor引用。一种是通过path，另一种是创建actor，获取它的引用，然后远程发布。先介绍第一种。</p>
<p>REPL控制台是一个很好的交互工具。进入到chapter6目录下，执行sbt console进入REPL，我们需要开启两个session，也就是两个REPL。为了使远程生效，我们需要在src/main/resources下提供一个配置文件application.conf，REPL启动的时候会自动加载它。</p>
<p>在REPL中执行:paste后，贴入以下代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">val conf="""</div><div class="line">akka &#123;</div><div class="line">  actor &#123;</div><div class="line">    provider = "akka.remote.RemoteActorRefProvider" // 选择 Remote ActorRef Provider来启动远程</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  // 远程配置</div><div class="line">  remote &#123; </div><div class="line">    enabled-transports = ["akka.remote.netty.tcp"] // 启用TCP</div><div class="line">    netty.tcp &#123;</div><div class="line">      hostname = "0.0.0.0"</div><div class="line">      port = 2552</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">"""</div></pre></td></tr></table></figure></p>
<p>我们会将这段配置信息加载进ActorSystem。需要注意的是它定义了一个ActorRefProvider来启动akka-remote module。顾名思义，他就是负责远程Actor的ActorRef。</p>
<p>下面代码首先引入必须的配置和actor包，然后把配置加载进了ActorSystem：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">import</span> com.typesafe.config._</div><div class="line"> <span class="keyword">import</span> com.typesafe.config._</div><div class="line"></div><div class="line"> scala&gt; <span class="keyword">import</span> akka.actor._</div><div class="line"> <span class="keyword">import</span> akka.actor._</div><div class="line"></div><div class="line"><span class="comment">// 解析字符串配置为对象config</span></div><div class="line"> scala&gt; <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.parseString(conf)</div><div class="line"> config: com.typesafe.config.<span class="type">Config</span> = ....</div><div class="line"></div><div class="line"><span class="comment">// 使用config对象创建ActorSystem</span></div><div class="line"> scala&gt; <span class="keyword">val</span> backend = <span class="type">ActorSystem</span>(<span class="string">"backend"</span>, config)</div><div class="line"> [<span class="type">Remoting</span>] <span class="type">Starting</span> remoting</div><div class="line"> .....</div><div class="line"> [<span class="type">Remoting</span>] <span class="type">Remoting</span> now listens on addresses:</div><div class="line"> [akka.tcp:<span class="comment">//backend@0.0.0.0:2551]</span></div><div class="line"> backend: akka.actor.<span class="type">ActorSystem</span> = akka:<span class="comment">//backend</span></div></pre></td></tr></table></figure></p>
<p>随着敲完最后一行，我们启动了一个启动了远程的ActorSystem。通过启动远程的config对象，我们启动了后端ActorSystem。如果忘了没有使用这个config，默认akka的application.conf里是不启用远程功能的。下面我们弄一个直接输出输入数据的小的actor：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">scala&gt; :paste</div><div class="line"><span class="comment">// Entering paste mode (ctrl-D to finish)</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line"><span class="keyword">case</span> m =&gt; println(<span class="string">s"received <span class="subst">$m</span>!"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Exiting paste mode, now interpreting.</span></div><div class="line"><span class="comment">// 使用后端ActorSystem创建这个简单的Actor并命名为simple</span></div><div class="line">scala&gt; backend.actorOf(<span class="type">Props</span>[<span class="type">Simple</span>], <span class="string">"simple"</span>)</div></pre></td></tr></table></figure></p>
<p>这个简单的actor已经运行在后端ActorSystem上了，并且有了名字simple，这样其他的node就可以找到它了。下面我们另起一个终端，开始编写前端：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">val conf = """</div><div class="line">akka &#123;</div><div class="line"></div><div class="line">  actor &#123;</div><div class="line">    provider = "akka.remote.RemoteActorRefProvider"</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  remote &#123;</div><div class="line">    enabled-transports = ["akka.remote.netty.tcp"]</div><div class="line">    netty.tcp &#123;</div><div class="line">      hostname = "0.0.0.0"</div><div class="line">      port = 2551 // 注意端口不同</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">"""</div><div class="line"></div><div class="line"> import com.typesafe.config._</div><div class="line"></div><div class="line"> import akka.actor._</div><div class="line"></div><div class="line"> val config = ConfigFactory.parseString(conf)</div><div class="line"> val frontend= ActorSystem("frontend", config)</div><div class="line"> [Remoting] Starting remoting</div><div class="line"> .....</div><div class="line"> [Remoting] Remoting now listens on addresses:</div><div class="line"> [akka.tcp://backend@0.0.0.0:2552]</div><div class="line"> frontend: akka.actor.ActorSystem = akka://frontend</div></pre></td></tr></table></figure></p>
<p>config同样被加载进了前端的actorSystem。前端actorSystem已经启用了远程，而且启动起来了。下面我们想办法在前端获取Simple Actor的引用。我们首先构建一个actor path。下图是path的组成：<br><img src="/imgs/akka/akka_6_remote_actor_path.png" alt="actor path的组成"></p>
<p>我们可以使用前端actorSystem的actorSelection方法通过path获取到后端ActorSystem的simple ActorRef：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; :paste</div><div class="line"><span class="comment">// Entering paste mode (ctrl-D to finish)</span></div><div class="line"><span class="keyword">val</span> path = <span class="string">"akka.tcp://backend@0.0.0.0:2551/user/simple"</span></div><div class="line"><span class="keyword">val</span> simple = frontend.actorSelection(path)</div><div class="line"><span class="comment">// Exiting paste mode, now interpreting.</span></div><div class="line">path: <span class="type">String</span> = akka.tcp:<span class="comment">//backend@0.0.0.0:2551/user/simple</span></div><div class="line">simple: akka.actor.<span class="type">ActorSelection</span> =</div><div class="line"><span class="type">ActorSelection</span>[<span class="type">Actor</span>[akka.tcp:<span class="comment">//backend@0.0.0.0:2551/]/user/simple]</span></div></pre></td></tr></table></figure></p>
<p>ctorSelection可以用来发送一些message给所有符合条件的actor。下面我们就在前端发送一个信息给后端：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scala&gt; simple ! <span class="string">"Hello Remote World!"</span></div></pre></td></tr></table></figure></p>
<p>切换到后端的终端上，可以看到，我们收到并打印出了这条message：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scala&gt; received <span class="type">Hello</span> <span class="type">Remote</span> <span class="type">World</span>!!</div></pre></td></tr></table></figure></p>
<p>过程是message被序列化，发送给一个TCP socket，通过远程module收到，然后反序列化，再交给后端的Simple Actor处理。</p>
<h4 id="6-2-3-远程查找"><a href="#6-2-3-远程查找" class="headerlink" title="6.2.3 远程查找"></a>6.2.3 远程查找</h4><p>我们并不会直接在RestInterface actor中直接创建BoxOffice actor，而是在后端node上找BoxOffice。如下图：<br><img src="/imgs/akka/akka_6_remotelooup_boxoffice_actor.png" alt="远程查找BoxOffice actor"><br>前面版本的RestInterface是直接创建的BoxOffice actor：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> boxOffice = context.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>], <span class="string">"boxOffice"</span>)</div></pre></td></tr></table></figure></p>
<p>这样调用的话二者就是直接的父子关系。为了让app更灵活一些，使之也能适应分布式系统，我们把这段代码放进一个trait，然后后面再mixin。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个trait必须被mixin进一个actor才能使用context</span></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BoxOfficeCreator</span> </span>&#123; <span class="keyword">this</span>: <span class="type">Actor</span> =&gt;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createBoxOffice</span></span>:<span class="type">ActorRef</span> = context.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>],<span class="string">"boxOffice"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RestApi trait包含了RestInterface actor的所有逻辑</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestInterface</span> <span class="keyword">extends</span> <span class="title">HttpServiceActor</span></span></div><div class="line">                    <span class="keyword">with</span> <span class="type">RestApi</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= runRoute(routes)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RestApi</span> <span class="keyword">extends</span> <span class="title">HttpService</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> <span class="keyword">with</span> <span class="title">BoxOfficeCreator</span> </span>&#123; actor: <span class="type">Actor</span> =&gt;</div><div class="line">  <span class="keyword">val</span> boxOffice = createBoxOffice <span class="comment">//使用BoxOfficeCreator trait中定义的方法创建BoxOffice</span></div><div class="line">	......</div><div class="line">	.....</div></pre></td></tr></table></figure></p>
<p>这样我们把创建BoxOffice的代码抽取到了一个trait中，然后在RestInterface把它设置为创建本地boxOffice的默认方法。</p>
<p>下面就定义三个入口方法：SingleNodeMain、FrontendMain、BackendMain。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单点</span></div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"singlenode"</span>, config)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> restInterface = system.actorOf(<span class="type">Props</span>[<span class="type">RestInterface</span>],</div><div class="line">                                     <span class="string">"restInterface"</span>)</div><div class="line"></div><div class="line"><span class="comment">// FrontendMain</span></div><div class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"frontend"</span>)</div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"frontend"</span>, config)</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// mixin RemoteBoxOfficeCreator trait </span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FrontendRestInterface</span> <span class="keyword">extends</span> <span class="title">RestInterface</span></span></div><div class="line">                              <span class="keyword">with</span> <span class="type">RemoteBoxOfficeCreator</span></div><div class="line"></div><div class="line">  <span class="comment">// 使用mixin的RemoteBoxOfficeCreator trait的FrontendRestInterface创建rest接口</span></div><div class="line">  <span class="keyword">val</span> restInterface = system.actorOf(<span class="type">Props</span>[<span class="type">FrontendRestInterface</span>],</div><div class="line">                                     <span class="string">"restInterface"</span>)</div><div class="line"></div><div class="line"><span class="comment">// BackendMain</span></div><div class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"backend"</span>)</div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"backend"</span>, config)</div><div class="line"></div><div class="line">  system.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>], <span class="string">"boxOffice"</span>)</div></pre></td></tr></table></figure>
<p>以上三个入口分别加载的是singlenode.conf, frontend.conf ， backend.conf配置文件里的配置。frontend.conf相对多出一个部分来指定怎样找boxoffice actor。RemoteBoxOfficeCreator负责加载这部分配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">backend &#123;</div><div class="line">  host = &quot;0.0.0.0&quot;</div><div class="line">  port = 2552</div><div class="line">  protocol = &quot;akka.tcp&quot;</div><div class="line">  system = &quot;backend&quot;</div><div class="line">  actor = &quot;user/boxOffice&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>boxoffice actor的路径是从这个配置部分获取并构建的。下面就是像前面REPL一样使用Actor Selection获取远程Actor，一旦确认后端正常，我们就可以尝试发送message了。这次我们希望使用ActorRef而不是单节点那样使用，下面是RemoteBoxOfficeCreator的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RemoteBoxOfficeCreator</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"frontend"</span>).getConfig(<span class="string">"backend"</span>)</div><div class="line">  <span class="keyword">val</span> host = config.getString(<span class="string">"host"</span>)</div><div class="line">  <span class="keyword">val</span> port = config.getInt(<span class="string">"port"</span>)</div><div class="line">  <span class="keyword">val</span> protocol = config.getString(<span class="string">"protocol"</span>)</div><div class="line">  <span class="keyword">val</span> systemName = config.getString(<span class="string">"system"</span>)</div><div class="line">  <span class="keyword">val</span> actorName = config.getString(<span class="string">"actor"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RemoteBoxOfficeCreator</span> <span class="keyword">extends</span> <span class="title">BoxOfficeCreator</span> </span>&#123; <span class="keyword">this</span>:<span class="type">Actor</span> =&gt;</div><div class="line">  <span class="keyword">import</span> <span class="type">RemoteBoxOfficeCreator</span>._</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createPath</span></span>:<span class="type">String</span> = &#123;</div><div class="line">    <span class="string">s"<span class="subst">$protocol</span>://<span class="subst">$systemName</span>@<span class="subst">$host</span>:<span class="subst">$port</span>/<span class="subst">$actorName</span>"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createBoxOffice</span></span>:<span class="type">ActorRef</span> = &#123;</div><div class="line">    <span class="keyword">val</span> path = createPath</div><div class="line">    context.actorOf(<span class="type">Props</span>(classOf[<span class="type">RemoteLookup</span>],path), <span class="string">"lookupBoxOffice"</span>) <span class="comment">// 创建一个负责寻找boxoffice actor的actor，这个actor的参数是远程boxoffice的path</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RemoteBoxOfficeCreator创建了一个额外的actor RemoteLookup来寻找boxOffice。在前面版本的akka里你可能会使用actorFor方法来直接获取一个远程actor的ActorRef。但是这个方法目前已经过期了，因为如果actor本身挂掉的话，他返回的ActorRef的表现并不完全像本地actor一样。还有就是通过actorFor返回的ActorRef可以指向一个新建的远程actor实例，这对本地context来说绝无可能。再一个原因就是不能像本地actor那样监控它的终结message。所以把这个方法废除了。取而代之的是RemoteLookup actor：</p>
<ul>
<li>后端ActorSystem可能还没有启动，或者暂时挂掉了，正在重启</li>
<li>boxOffice actor本身也可能挂掉重启中</li>
<li>理想状态下我们能先于前端启动后端</li>
</ul>
<p>RemoteLookup负责处理以上这些场景。下路是RemoteLookup在RestInterface和BoxOffice的作用，它主要负责传递message给RestInterface：<br><img src="/imgs/akka/akka_6_remotelooup_actor.png" alt="RestInterface actor"></p>
<p>RemoteLookup actor是一个只包含两种状态的状态机：identify或者active。它使用become方法在这两种状态之间进行切换。当RemoteLookup想要获取一个BoxOffice的ActorRef的时候，如果它暂时还没有，就是在identify状态。不然它就是在active状态，传递所有的message到一个有效的BoxOffice ActorRef。</p>
<p>如果RemoteLookup发现BoxOffice已经被终结了，他会在接收不到message的一段时间后，重新获取一个有效的ActorRef。我们使用RemoteDeath监控这种情况。这东西我们并不陌生，跟普通的actor监控是一样的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteLookup</span>(<span class="params">path:<span class="type">String</span></span>)</span></div><div class="line">  <span class="keyword">extends</span> <span class="type">Actor</span> <span class="keyword">with</span> <span class="type">ActorLogging</span> &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 若3秒内没有收到任何message，就发送一个ReceiveTimeout消息 </span></div><div class="line">  context.setReceiveTimeout(<span class="number">3</span> seconds)</div><div class="line">  <span class="comment">// 马上请求actor的identify</span></div><div class="line">  sendIdentifyRequest()</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sendIdentifyRequest</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="comment">// 使用path获取actor</span></div><div class="line">    <span class="keyword">val</span> selection = context.actorSelection(path)</div><div class="line">    <span class="comment">// 向actorSelection发送一个Identify message</span></div><div class="line">    selection ! <span class="type">Identify</span>(path)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= identify</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">identify</span></span>:<span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">ActorIdentity</span>(`path`, <span class="type">Some</span>(actor)) =&gt; <span class="comment">// 某个actor已经被确认(identified)了，返回它的ActorRef</span></div><div class="line">      context.setReceiveTimeout(<span class="type">Duration</span>.<span class="type">Undefined</span>) <span class="comment">// 既然当前actor已经是active了，就不用发送ReceiveTimeout了</span></div><div class="line">      log.info(<span class="string">"switching to active state"</span>)</div><div class="line">      context.become(active(actor))	<span class="comment">// 修改状态</span></div><div class="line">      context.watch(actor)		<span class="comment">// 监视</span></div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="type">ActorIdentity</span>(`path`, <span class="type">None</span>) =&gt;   <span class="comment">// actor还不可用，后端连不上，或者还没有启动</span></div><div class="line">      log.error(<span class="string">s"Remote actor with path <span class="subst">$path</span> is not available."</span>)</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="type">ReceiveTimeout</span> =&gt; <span class="comment">// 如果还没有收到message，就继续identify远程actor</span></div><div class="line">      sendIdentifyRequest()</div><div class="line"></div><div class="line">    <span class="keyword">case</span> msg:<span class="type">Any</span> =&gt;   	<span class="comment">// 在identify接收状态下，不发送任何message</span></div><div class="line">      log.error(<span class="string">s"Ignoring message <span class="subst">$msg</span>, remote actor is not ready yet."</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">active</span></span>(actor: <span class="type">ActorRef</span>): <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(actorRef) =&gt;  	<span class="comment">// 如果远程的actor被终结，RemoteLookup应修改它的状态到identify接收状态</span></div><div class="line">      log.info(<span class="string">"Actor $actorRef terminated."</span>)</div><div class="line">      log.info(<span class="string">"switching to identify state"</span>)</div><div class="line">      context.become(identify)</div><div class="line">      context.setReceiveTimeout(<span class="number">3</span> seconds)</div><div class="line">      sendIdentifyRequest()</div><div class="line"></div><div class="line">    <span class="keyword">case</span> msg:<span class="type">Any</span> =&gt; actor forward msg		<span class="comment">// 当远程actor是active的时候，向下传递所有其他message</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发送Identify message到ActorSelection来获取boxOffice的ActorRef。后端ActorSystem的远程module对应返回一个包含远程actor的ActorRef的 ActorIdentity message。</p>
<p>这样就完成了从一个单节点应用改到前后端node。除了能够远程通信，前端和后端还可以分开启动，前端会去找boxoffice，当boxoffice可用的时候就与之通信，不可用就采取其他措施。</p>
<p>最后就是运行FrontendMain和BackendMain。启动两个终端，分别使用sbt run指定入口类运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[info] ...</div><div class="line">[info] ... (sbt messages)</div><div class="line">[info] ...</div><div class="line">Multiple main classes detected, select one to run:</div><div class="line">[1] com.goticks.SingleNodeMain</div><div class="line">[2] com.goticks.FrontendMain</div><div class="line">[3] com.goticks.BackendMain</div><div class="line">Enter number:</div></pre></td></tr></table></figure></p>
<p>测试一下如果kill掉后端，再重启。</p>
<p>远程event的生命周期默认是打在日志里的，可以帮主我们更快定位问题。我们还可以使用actorSystem的eventStream方法定于远程生命周期event，后面第十章会提到。考虑到连接管理，再考虑到我们可以像本地actor一样监视远程actor，我们就没必要再针对event做什么额外操作了。</p>
<p>重新看一下修改的地方：</p>
<ul>
<li>抽出 BoxOfficeCreator trait。远程版本中向后端请求查找Boxoffice。</li>
<li>RemoteBoxOfficeCreator在RestInterface和BoxOffice之间添加了一个RemoteLookup actor。它负责传递他收到的所有的消息给boxoffice。它还identifyboxoffice的actorRef，并且远程监视boxoffice的actor。</li>
</ul>
<h4 id="6-2-4-远程发布"><a href="#6-2-4-远程发布" class="headerlink" title="6.2.4 远程发布"></a>6.2.4 远程发布</h4><p>前面说到akka提供了两种方式获取远程actor的ActorRef。下面我们介绍第二种，远程发布。</p>
<p>远程发布可以通过编程或配置实现。我们先弄一下配置方式的远程发布。它的好处就是不需要重新构建app就可以修改集群。标准的 BoxOfficeCreator trait 创建boxOffice，并把后者当做自己的一个子actor：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> boxOffice = context.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>], <span class="string">"boxOffice"</span>)</div></pre></td></tr></table></figure></p>
<p>local path是/restInterface/boxOffice，注意这里没有/user。当我们使用基于配置的远程发布的时候，我们只需要告诉前端actorSystem，创建/restInterface/boxOffice的actor的时候，应该是远程创建。通过如下配置实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actor &#123;</div><div class="line">  provider = &quot;akka.remote.RemoteActorRefProvider&quot;</div><div class="line"></div><div class="line">  deployment &#123;</div><div class="line">    /restInterface/boxOffice &#123;  // 使用这个path的actor都应该被远程发布</div><div class="line">      remote = &quot;akka.tcp://backend@0.0.0.0:2552&quot;   // 远程发布的目标地址，应该就是后端监听的端口</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基于编程的远程发布相比起来简直就没有存在的必要。大多数情况下我们都使用基于配置的远程发布。但是有时，假如你要通过CNAMES引用不同的node，写代码就方便些。当时用akka-cluster的时候，完全动态远程发布就很有意义了，因为它可以支持动态membership。下面是一个基于编程的远程发布实例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> uri = <span class="string">"akka.tcp://backend@0.0.0.0:2552"</span></div><div class="line"> <span class="keyword">val</span> backendAddress = <span class="type">AddressFromURIString</span>(uri) <span class="comment">// 从uri创建一个后端地址</span></div><div class="line"> <span class="comment">// 使用远程发布范围创建一个Props</span></div><div class="line"> <span class="keyword">val</span> props = <span class="type">Props</span>[<span class="type">BoxOffice</span>].withDeploy(</div><div class="line">   <span class="type">Deploy</span>(scope = <span class="type">RemoteScope</span>(backendAddress))</div><div class="line"> )</div><div class="line"> context.actorOf(props, <span class="string">"boxOffice"</span>)</div></pre></td></tr></table></figure></p>
<p>上面代码也是在后端远程创建与发布了一个boxOffice。</p>
<p>注意，远程发布并不是akka把实际的BoxOffice的class文件传送给远程server实现，而是远程server本身就有这个actor。如果后端远程ActorSystem挂掉并重启，这个ActorRef并不会自动关联到新的远程actor实例。这个实例是通过远程发布的，所以后端ActorSystem中不能是已经启动了的。基于这两点改变，下面是新的Main方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前端不再创建boxOffice</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">BackendRemoteDeployMain</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"backend"</span>)</div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"backend"</span>, config)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 后端不再mixin一些trait，使用默认的BoxOfficeCreator</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">FrontendRemoteDeployWatchMain</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load(<span class="string">"frontend-remote-deploy"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> host = config.getString(<span class="string">"http.host"</span>)</div><div class="line">  <span class="keyword">val</span> port = config.getInt(<span class="string">"http.port"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"frontend"</span>, config)</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">RestInterfaceWatch</span> <span class="keyword">extends</span> <span class="title">RestInterface</span></span></div><div class="line">                           <span class="keyword">with</span> <span class="type">ConfiguredRemoteBoxOfficeDeployment</span></div><div class="line"></div><div class="line">  <span class="keyword">val</span> restInterface = system.actorOf(<span class="type">Props</span>[<span class="type">RestInterfaceWatch</span>],</div><div class="line">  <span class="string">"restInterface"</span>)</div><div class="line"></div><div class="line">  <span class="type">Http</span>(system).manager ! <span class="type">Bind</span>(listener = restInterface,</div><div class="line">  interface = host,</div><div class="line">  port =port)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分别在两个终端下运行这两个main方法，尝试使用httpie创建event，会看到下面的message在前端ActorSystem打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// very long message, formatted in a couple of lines to fit.</div><div class="line">INFO [RestInterface]: Received new event Event(RHCP,10), sending to</div><div class="line">Actor[akka.tcp://backend@0.0.0.0:2552/remote/akka.tcp/</div><div class="line"> frontend@0.0.0.0:2551/user/restInterface/boxOffice#-1230704641]</div></pre></td></tr></table></figure></p>
<p>这是说前端向后端发送了一个message来远程发布了boxOffice。</p>
<p>目前来说一切都顺利。可是有个问题：如果前端尝试远程发布的时候后端没有启动会咋样，因为还是会获得一个ActorRef。即便后端ActorSystem一会儿启动了，这个ActorRef还是不可用。要解决这个问题，我们还是要对这个ActorRef添加监视。我们需要像前面RemoteLookup actor那样放一个actor在RestInterface和boxOffice之间，这次是RemoteBoxOfficeForwarder。</p>
<p>我们需要稍微修改以下配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actor &#123;</div><div class="line">  provider = &quot;akka.remote.RemoteActorRefProvider&quot;</div><div class="line"></div><div class="line">  deployment &#123;</div><div class="line">    /restInterface/forwarder/boxOffice &#123;</div><div class="line">      remote = &quot;akka.tcp://backend@0.0.0.0:2552&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是ConfiguredRemoteBoxOfficeDeployment和RemoteBoxOfficeForwarder的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConfiguredRemoteBoxOfficeDeployment</span> <span class="keyword">extends</span> <span class="title">BoxOfficeCreator</span> </span>&#123; <span class="keyword">this</span>:<span class="type">Actor</span> =&gt;</div><div class="line"></div><div class="line">  <span class="comment">// 创建一个forwarder来负责监视和发布远程的BoxOffice</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createBoxOffice</span> </span>= &#123;</div><div class="line">    context.actorOf(<span class="type">Props</span>[<span class="type">RemoteBoxOfficeForwarder</span>],</div><div class="line">                           <span class="string">"forwarder"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteBoxOfficeForwarder</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> </span>&#123;</div><div class="line">  context.setReceiveTimeout(<span class="number">3</span> seconds)</div><div class="line"></div><div class="line">  <span class="comment">// 远程发布并监视BoxOffice</span></div><div class="line">  deployAndWatch()</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deployAndWatch</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> actor = context.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>], <span class="string">"boxOffice"</span>)</div><div class="line">    context.watch(actor)</div><div class="line">    log.info(<span class="string">"switching to maybe active state"</span>)</div><div class="line">    context.become(maybeActive(actor))</div><div class="line">    context.setReceiveTimeout(<span class="type">Duration</span>.<span class="type">Undefined</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= deploying</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deploying</span></span>:<span class="type">Receive</span> = &#123;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="type">ReceiveTimeout</span> =&gt;</div><div class="line">      deployAndWatch()</div><div class="line"></div><div class="line">    <span class="keyword">case</span> msg:<span class="type">Any</span> =&gt;</div><div class="line">      log.error(<span class="string">s"Ignoring message <span class="subst">$msg</span>, remote actor is not ready yet."</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">maybeActive</span></span>(actor:<span class="type">ActorRef</span>): <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(actorRef) =&gt; 	<span class="comment">// 远程发布的actor被终结，那就重新远程发布一个</span></div><div class="line">      log.info(<span class="string">"Actor $actorRef terminated."</span>)</div><div class="line">      log.info(<span class="string">"switching to deploying state"</span>)</div><div class="line">      context.become(deploying)</div><div class="line">      context.setReceiveTimeout(<span class="number">3</span> seconds)</div><div class="line">      deployAndWatch()</div><div class="line"></div><div class="line">    <span class="keyword">case</span> msg:<span class="type">Any</span> =&gt; actor forward msg</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RemoteBoxOfficeForwarder和上文的RemoteLookup特别像，都有一个状态机，不过它是 ‘deploying’ 或  ‘maybe active’。没有actor selection，我们不能确认远程actor是否已经真的被发布了。 为RemoteBoxOfficeForwarder添加远程actorSelection的任务就交给读者你了，就是当前’maybe’的状态机。</p>
<p>前端的main类mixin了ConfiguredRemoteBoxOfficeDeployment。看一下FrontendRemoteDeployWatchMain：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestInterfaceWatch</span> <span class="keyword">extends</span> <span class="title">RestInterface</span></span></div><div class="line">                         <span class="keyword">with</span> <span class="type">ConfiguredRemoteBoxOfficeDeployment</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> restInterface = system.actorOf(<span class="type">Props</span>[<span class="type">RestInterfaceWatch</span>],</div><div class="line"><span class="string">"restInterface"</span>)</div></pre></td></tr></table></figure></p>
<p>重新启动前后端的程序，测试一把。</p>
<p>我们把lookup和远程发布两种方式都可以使程序特别有韧性。即便在只有两个node的时候，我们最好也能在最开始就弄的特别有韧性。</p>
<h4 id="6-2-5-Multi-JVM-testing"><a href="#6-2-5-Multi-JVM-testing" class="headerlink" title="6.2.5 Multi-JVM testing"></a>6.2.5 Multi-JVM testing</h4><p>sbt multi-jvm插件可以用来进行跨JVM的测试，这对于分布式系统是很重要的。需要在sbt配置文件中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addSbtPlugin(&quot;com.typesafe.sbt&quot; % &quot;sbt-multi-jvm&quot; % &quot;0.3.5&quot;)</div></pre></td></tr></table></figure></p>
<p>我们需要额外添加另一个sbt构件文件来使用它。 Multi-JVM插件只支持scala DSL版本的sbt下过目文件，是；uoyi我们需要在chapter6/project文件夹下添加GoTicksBuild.scala文件。Sbt会自动merge build.sbt和GoTicksBuild.scala。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sbt._</div><div class="line"><span class="keyword">import</span> <span class="type">Keys</span>._</div><div class="line"><span class="keyword">import</span> com.typesafe.sbt.<span class="type">SbtMultiJvm</span></div><div class="line"><span class="keyword">import</span> com.typesafe.sbt.<span class="type">SbtMultiJvm</span>.<span class="type">MultiJvmKeys</span>.&#123; <span class="type">MultiJvm</span> &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">GoTicksBuild</span> <span class="keyword">extends</span> <span class="title">Build</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> buildSettings = <span class="type">Defaults</span>.defaultSettings ++ multiJvmSettings ++ <span class="type">Seq</span>(</div><div class="line">    crossPaths   := <span class="literal">false</span></div><div class="line">  )</div><div class="line"></div><div class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> goticks = <span class="type">Project</span>(</div><div class="line">    id = <span class="string">"goticks"</span>,</div><div class="line">    base = file(<span class="string">"."</span>),</div><div class="line">    settings = buildSettings ++ <span class="type">Project</span>.defaultSettings</div><div class="line">  ) configs(<span class="type">MultiJvm</span>)</div><div class="line"></div><div class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> multiJvmSettings = <span class="type">SbtMultiJvm</span>.multiJvmSettings ++ <span class="type">Seq</span>(</div><div class="line">    <span class="comment">// make sure that MultiJvm test are compiled by the default test compilation</span></div><div class="line">    compile in <span class="type">MultiJvm</span> &lt;&lt;= (compile in <span class="type">MultiJvm</span>) triggeredBy (compile in <span class="type">Test</span>),</div><div class="line">    <span class="comment">// disable parallel tests</span></div><div class="line">    parallelExecution in <span class="type">Test</span> := <span class="literal">false</span>,</div><div class="line">    <span class="comment">// make sure that MultiJvm tests are executed by the default test target</span></div><div class="line">    executeTests in <span class="type">Test</span> &lt;&lt;=</div><div class="line">      ((executeTests in <span class="type">Test</span>), (executeTests in <span class="type">MultiJvm</span>)) map &#123;</div><div class="line">        <span class="keyword">case</span> ((_, testResults), (_, multiJvmResults))  =&gt;</div><div class="line">          <span class="keyword">val</span> results = testResults ++ multiJvmResults</div><div class="line">          (<span class="type">Tests</span>.overall(results.values), results)</div><div class="line">      &#125;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你对sbt不熟，不用担心这个文件的细节。上面基本就是配置了multi-jvm插件，确认multi-jvm测试使用普通单元测试执行。要是想看看sbt的话，可以参考SBT in Action。</p>
<p>多jvm的测试默认是应该写在 src/multi-jvm/scala 文件夹下。既然我们的项目已经正确配置了，那么我们可以开始写代码测试goticks的前端和后端了。</p>
<p>首先定义MultiNodeConfig描述测试的node的角色。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClientServerConfig</span> <span class="keyword">extends</span> <span class="title">MultiNodeConfig</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> frontend = role(<span class="string">"frontend"</span>)</div><div class="line">  <span class="keyword">val</span> backend = role(<span class="string">"backend"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义了两个role。role用来确认参与测试的node运行的代码，以便于针对性的测试。在写测试之前我们需要些一些基础设施代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">STMultiNodeSpec</span> <span class="keyword">extends</span> <span class="title">MultiNodeSpecCallbacks</span></span></div><div class="line"><span class="keyword">with</span> <span class="type">WordSpec</span> <span class="keyword">with</span> <span class="type">MustMatchers</span> <span class="keyword">with</span> <span class="type">BeforeAndAfterAll</span> &#123;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">beforeAll</span></span>() = multiNodeSpecBeforeAll()</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">afterAll</span></span>() = multiNodeSpecAfterAll()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中继承MultiNodeSpecCallbacks以获取回调函数，然后下面重写了几个回调函数。</p>
<p>下面我们创建MultiNodeSpec，并让他mixin刚刚定义的STMultiNodeSpec。两个版本的ClientServerSpec会运行在不同的两个jvm上。下面是ClientServerSpec：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientServerSpecMultiJvmFrontend</span> <span class="keyword">extends</span> <span class="title">ClientServerSpec</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientServerSpecMultiJvmBackend</span> <span class="keyword">extends</span> <span class="title">ClientServerSpec</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientServerSpec</span> <span class="keyword">extends</span> <span class="title">MultiNodeSpec</span>(<span class="params"><span class="type">ClientServerConfig</span></span>)</span></div><div class="line"><span class="keyword">with</span> <span class="type">STMultiNodeSpec</span> <span class="keyword">with</span> <span class="type">ImplicitSender</span> &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 参加到这次测试的node个数</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialParticipants</span> </span>= roles.size</div></pre></td></tr></table></figure></p>
<p>ClientServerSpec使用了STMultiNodeSpec和ImplicitSender。后者设置testActor为所有message的默认sender，这样不用每次都设置了。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import后我们才可以访问到后端role</span></div><div class="line"><span class="keyword">import</span> <span class="type">ClientServerConfig</span>._</div><div class="line"></div><div class="line"><span class="comment">// 测试中使用TestRemoteBoxOfficeCreator，而不是RemoteBoxOfficeCreator</span></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TestRemoteBoxOfficeCreator</span> <span class="keyword">extends</span> <span class="title">RemoteBoxOfficeCreator</span> </span>&#123; <span class="keyword">this</span>:<span class="type">Actor</span> =&gt;</div><div class="line"></div><div class="line">  <span class="comment">// 重写方法，返回测试的path</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createPath</span></span>: <span class="type">String</span> = &#123;</div><div class="line">    <span class="keyword">val</span> actorPath = node(backend) / <span class="string">"user"</span> /<span class="string">"boxOffice"</span>		<span class="comment">//node方法返回后端role node的地址。这个表达式是创建了一个ActorPath</span></div><div class="line">    actorPath.toString</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前端和后端role node默认是在随机端口上运行。我们使用TestRemoteBoxOfficeCreator替代RemoteBoxOfficeCreator，因为后者是使用的frontend.conf文件中的配置。我们在测试中需要找的是不一样的环境。</p>
<p>看一下测试代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="string">"A Client Server configured app"</span> must &#123;</div><div class="line"></div><div class="line">    <span class="string">"wait for all nodes to enter a barrier"</span> in &#123;</div><div class="line">      enterBarrier(<span class="string">"startup"</span>) <span class="comment">// 启动所有的node</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="string">"be able to create an event and sell a ticket"</span> in &#123;</div><div class="line"></div><div class="line">      <span class="comment">// 运行在前端jvm的代码</span></div><div class="line">      runOn(frontend) &#123;</div><div class="line"> 	<span class="comment">// 等待后端发布</span></div><div class="line">        enterBarrier(<span class="string">"deployed"</span>)</div><div class="line">        <span class="comment">// 创建一个RestInterfaceMock</span></div><div class="line">	<span class="keyword">val</span> restInterface = system.actorOf(<span class="type">Props</span>(<span class="keyword">new</span> <span class="type">RestInterfaceMock</span> <span class="keyword">with</span> <span class="type">TestRemoteBoxOfficeCreator</span>))</div><div class="line"></div><div class="line">        <span class="keyword">val</span> path = node(backend) / <span class="string">"user"</span> / <span class="string">"boxOffice"</span></div><div class="line">        </div><div class="line">	<span class="comment">// 获取远程actor的actorSelection</span></div><div class="line">	<span class="keyword">val</span> actorSelection = system.actorSelection(path)</div><div class="line"></div><div class="line"> 	<span class="comment">// 向actorselection发送Identify消息</span></div><div class="line">        actorSelection.tell(<span class="type">Identify</span>(path), testActor)</div><div class="line"></div><div class="line">	<span class="comment">// 等待boxoffice汇报它是否可用。RemoteLookup类会负责获取boxoffice的ActorRef</span></div><div class="line">        <span class="keyword">val</span> actorRef = expectMsgPF() &#123;</div><div class="line">          <span class="keyword">case</span> <span class="type">ActorIdentity</span>(`path`, ref) =&gt; ref</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        restInterface ! <span class="type">Event</span>(<span class="string">"RHCP"</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">        expectMsg(<span class="type">EventCreated</span>)</div><div class="line"></div><div class="line">        restInterface ! <span class="type">TicketRequest</span>(<span class="string">"RHCP"</span>)</div><div class="line"></div><div class="line">        expectMsg(<span class="type">Ticket</span>(<span class="string">"RHCP"</span>, <span class="number">1</span>))</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 运行在后端JVM上的代码</span></div><div class="line">      runOn(backend) &#123;</div><div class="line">	<span class="comment">// 创建boxOffice，并命名为boxOffice，这样RemoteLookup就可以找到它了</span></div><div class="line">        system.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>], <span class="string">"boxOffice"</span>)</div><div class="line">	<span class="comment">// 发送后端已经部署的信号</span></div><div class="line">        enterBarrier(<span class="string">"deployed"</span>)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 测试结束</span></div><div class="line">      enterBarrier(<span class="string">"finished"</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这段测试可以分为4个部分。第一个是enterBarrier(“startup”)等待所有node启动。实际的测试会面就会指定前端和后端各自运行什么代码。前端会等后端启动成功的信号，然后执行测试。</p>
<p>后段代码只启动boxoffice，提供给前端使用。我们使用了RestInterfaceMock，TestRemoteBoxOfficeCreator。我们还是使用了RemoteLookup来等远程的actor被identify。 在发送message到远程boxoffice之前，我们先期望获得一个ActorIdentify message。</p>
<p>在项目目录下执行multi-jvm:test进行测试。</p>
<p>下图说明了测试的实际流程。<br><img src="/imgs/akka/akka_6_multi_jvm_test_flow.png" alt="Multi-JVM Test Flow"></p>
<p>单节点运行和client server 模式的最大区别就是actorRef的获取与监视。在RestInterface和boxOffice 之间添加一个Remote Lookup，获取更大的灵活性，也能够更好地处理actor挂掉的问题。我们怎样等待远程actorRef可用呢？actorSelection和Identify message机制可以搞定。</p>
<h2 id="6-3-总结"><a href="#6-3-总结" class="headerlink" title="6.3 总结"></a>6.3 总结</h2><p>记得本章开始的时候我们要分布式的理由么？</p>
<p>除了我们要做一些改变之外，还有一些不变的事情：</p>
<ul>
<li>我们使用ActorRef，不用关心它是远程actor还是本地actor</li>
<li>监控actor的API和local模式一样</li>
<li>除了协作者被网络分隔之外，我们通过中间actor，让RestInterface和BoxOffice互相通信。</li>
</ul>
<p>我们学到的新东西：</p>
<ul>
<li>REPL提供了一个简单友好的方式来探索分布式拓扑</li>
<li>multi-node-testkit使得分布式系统的测试特别简单，不管这些分布式系统是基于akka-remote还是 akka-cluster</li>
</ul>
<p>我们还没有处理在RemoteLookup和RemoteBoxOfficeForwarder的message丢失问题。下面的章节会介绍：</p>
<ul>
<li>怎样在合作node之间创建爱你可信赖的proxy</li>
<li>当后端node挂掉的时候处理TicketSellers丢失的问题</li>
<li>状态怎样在集群间复制</li>
</ul>
<p>但是。。在此之前，我们先看一下基于akka-cluster module的动态的node membership。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/akka/">akka</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://runningdata.github.io/2016/08/15/akka-in-action-读书笔记（6）/" data-title="akka in action 读书笔记（6） | Will&#39;s Blog" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/08/17/akka-in-action-读书笔记（7）/" title="akka in action 读书笔记（7）">
  <strong>上一篇：</strong><br/>
  <span>
  akka in action 读书笔记（7）</span>
</a>
</div>


<div class="next">
<a href="/2016/08/11/akka-in-action-读书笔记（5）/"  title="akka in action 读书笔记（5）">
 <strong>下一篇：</strong><br/> 
 <span>akka in action 读书笔记（5）
</span>
</a>
</div>

</nav>

	
<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2016/08/15/akka-in-action-读书笔记（6）/" data-title="akka in action 读书笔记（6）" data-url="https://runningdata.github.io/2016/08/15/akka-in-action-读书笔记（6）/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"ruoyuchen"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-scale-out"><span class="toc-number">1.</span> <span class="toc-text">6.1 scale out</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-通用网络拓扑"><span class="toc-number">1.0.1.</span> <span class="toc-text">6.1.1 通用网络拓扑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-为何要分布式编程模型"><span class="toc-number">1.0.2.</span> <span class="toc-text">6.1.2 为何要分布式编程模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-scale-out-with-remoting"><span class="toc-number">2.</span> <span class="toc-text">6.2 scale out with remoting</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-动手写程序"><span class="toc-number">2.0.1.</span> <span class="toc-text">6.2.1 动手写程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-远程REPL"><span class="toc-number">2.0.2.</span> <span class="toc-text">6.2.2 远程REPL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-远程查找"><span class="toc-number">2.0.3.</span> <span class="toc-text">6.2.3 远程查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-远程发布"><span class="toc-number">2.0.4.</span> <span class="toc-text">6.2.4 远程发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-5-Multi-JVM-testing"><span class="toc-number">2.0.5.</span> <span class="toc-text">6.2.5 Multi-JVM testing</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-总结"><span class="toc-number">3.</span> <span class="toc-text">6.3 总结</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/youdaonote/" title="youdaonote">youdaonote<sup>187</sup></a></li>
			
		
			
				<li><a href="/tags/源码/" title="源码">源码<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/akka/" title="akka">akka<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/flume/" title="flume">flume<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/ETL/" title="ETL">ETL<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/solr/" title="solr">solr<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/spring/" title="spring">spring<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/调度平台/" title="调度平台">调度平台<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/azkaban/" title="azkaban">azkaban<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/scala/" title="scala">scala<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/ambari/" title="ambari">ambari<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/quartz/" title="quartz">quartz<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/nodejs/" title="nodejs">nodejs<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Solr/" title="Solr">Solr<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/guava/" title="guava">guava<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/heroku/" title="heroku">heroku<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/hdfs/" title="hdfs">hdfs<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/hue/" title="hue">hue<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ElasticSearch/" title="ElasticSearch">ElasticSearch<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/willcup" target="_blank" title=" 我自己的github">github</a>
            
          </li>
        
          <li>
            
            	<a href="http://thisding.com" target="_blank" title="朋友的主页">Steven&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Will Chen in MeiTuan. <br/>
			元 亨 利 贞.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:chenxin15@meituan.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Will Chen">Will Chen</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fe6d1f421bbc9962127a50488f9ed37d1' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
